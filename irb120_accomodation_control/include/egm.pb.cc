// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm.proto

#include "egm.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)
namespace abb {
namespace egm {
class EgmHeaderDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmHeader>
      _instance;
} _EgmHeader_default_instance_;
class EgmCartesianDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmCartesian>
      _instance;
} _EgmCartesian_default_instance_;
class EgmQuaternionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmQuaternion>
      _instance;
} _EgmQuaternion_default_instance_;
class EgmEulerDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmEuler>
      _instance;
} _EgmEuler_default_instance_;
class EgmPoseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmPose>
      _instance;
} _EgmPose_default_instance_;
class EgmCartesianSpeedDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmCartesianSpeed>
      _instance;
} _EgmCartesianSpeed_default_instance_;
class EgmJointsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmJoints>
      _instance;
} _EgmJoints_default_instance_;
class EgmExternalJointsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmExternalJoints>
      _instance;
} _EgmExternalJoints_default_instance_;
class EgmPlannedDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmPlanned>
      _instance;
} _EgmPlanned_default_instance_;
class EgmSpeedRefDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmSpeedRef>
      _instance;
} _EgmSpeedRef_default_instance_;
class EgmPathCorrDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmPathCorr>
      _instance;
} _EgmPathCorr_default_instance_;
class EgmFeedBackDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmFeedBack>
      _instance;
} _EgmFeedBack_default_instance_;
class EgmMotorStateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmMotorState>
      _instance;
} _EgmMotorState_default_instance_;
class EgmMCIStateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmMCIState>
      _instance;
} _EgmMCIState_default_instance_;
class EgmRapidCtrlExecStateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmRapidCtrlExecState>
      _instance;
} _EgmRapidCtrlExecState_default_instance_;
class EgmTestSignalsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmTestSignals>
      _instance;
} _EgmTestSignals_default_instance_;
class EgmRobotDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmRobot>
      _instance;
} _EgmRobot_default_instance_;
class EgmSensorDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmSensor>
      _instance;
} _EgmSensor_default_instance_;
class EgmSensorPathCorrDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EgmSensorPathCorr>
      _instance;
} _EgmSensorPathCorr_default_instance_;
}  // namespace egm
}  // namespace abb
namespace protobuf_egm_2eproto {
void InitDefaultsEgmHeaderImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::_EgmHeader_default_instance_;
    new (ptr) ::abb::egm::EgmHeader();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmHeader::InitAsDefaultInstance();
}

void InitDefaultsEgmHeader() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmHeaderImpl);
}

void InitDefaultsEgmCartesianImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::_EgmCartesian_default_instance_;
    new (ptr) ::abb::egm::EgmCartesian();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmCartesian::InitAsDefaultInstance();
}

void InitDefaultsEgmCartesian() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmCartesianImpl);
}

void InitDefaultsEgmQuaternionImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::_EgmQuaternion_default_instance_;
    new (ptr) ::abb::egm::EgmQuaternion();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmQuaternion::InitAsDefaultInstance();
}

void InitDefaultsEgmQuaternion() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmQuaternionImpl);
}

void InitDefaultsEgmEulerImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::_EgmEuler_default_instance_;
    new (ptr) ::abb::egm::EgmEuler();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmEuler::InitAsDefaultInstance();
}

void InitDefaultsEgmEuler() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmEulerImpl);
}

void InitDefaultsEgmPoseImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_2eproto::InitDefaultsEgmCartesian();
  protobuf_egm_2eproto::InitDefaultsEgmQuaternion();
  protobuf_egm_2eproto::InitDefaultsEgmEuler();
  {
    void* ptr = &::abb::egm::_EgmPose_default_instance_;
    new (ptr) ::abb::egm::EgmPose();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmPose::InitAsDefaultInstance();
}

void InitDefaultsEgmPose() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmPoseImpl);
}

void InitDefaultsEgmCartesianSpeedImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::_EgmCartesianSpeed_default_instance_;
    new (ptr) ::abb::egm::EgmCartesianSpeed();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmCartesianSpeed::InitAsDefaultInstance();
}

void InitDefaultsEgmCartesianSpeed() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmCartesianSpeedImpl);
}

void InitDefaultsEgmJointsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::_EgmJoints_default_instance_;
    new (ptr) ::abb::egm::EgmJoints();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmJoints::InitAsDefaultInstance();
}

void InitDefaultsEgmJoints() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmJointsImpl);
}

void InitDefaultsEgmExternalJointsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::_EgmExternalJoints_default_instance_;
    new (ptr) ::abb::egm::EgmExternalJoints();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmExternalJoints::InitAsDefaultInstance();
}

void InitDefaultsEgmExternalJoints() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmExternalJointsImpl);
}

void InitDefaultsEgmPlannedImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_2eproto::InitDefaultsEgmJoints();
  protobuf_egm_2eproto::InitDefaultsEgmPose();
  {
    void* ptr = &::abb::egm::_EgmPlanned_default_instance_;
    new (ptr) ::abb::egm::EgmPlanned();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmPlanned::InitAsDefaultInstance();
}

void InitDefaultsEgmPlanned() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmPlannedImpl);
}

void InitDefaultsEgmSpeedRefImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_2eproto::InitDefaultsEgmJoints();
  protobuf_egm_2eproto::InitDefaultsEgmCartesianSpeed();
  {
    void* ptr = &::abb::egm::_EgmSpeedRef_default_instance_;
    new (ptr) ::abb::egm::EgmSpeedRef();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmSpeedRef::InitAsDefaultInstance();
}

void InitDefaultsEgmSpeedRef() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmSpeedRefImpl);
}

void InitDefaultsEgmPathCorrImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_2eproto::InitDefaultsEgmCartesian();
  {
    void* ptr = &::abb::egm::_EgmPathCorr_default_instance_;
    new (ptr) ::abb::egm::EgmPathCorr();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmPathCorr::InitAsDefaultInstance();
}

void InitDefaultsEgmPathCorr() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmPathCorrImpl);
}

void InitDefaultsEgmFeedBackImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_2eproto::InitDefaultsEgmJoints();
  protobuf_egm_2eproto::InitDefaultsEgmPose();
  {
    void* ptr = &::abb::egm::_EgmFeedBack_default_instance_;
    new (ptr) ::abb::egm::EgmFeedBack();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmFeedBack::InitAsDefaultInstance();
}

void InitDefaultsEgmFeedBack() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmFeedBackImpl);
}

void InitDefaultsEgmMotorStateImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::_EgmMotorState_default_instance_;
    new (ptr) ::abb::egm::EgmMotorState();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmMotorState::InitAsDefaultInstance();
}

void InitDefaultsEgmMotorState() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmMotorStateImpl);
}

void InitDefaultsEgmMCIStateImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::_EgmMCIState_default_instance_;
    new (ptr) ::abb::egm::EgmMCIState();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmMCIState::InitAsDefaultInstance();
}

void InitDefaultsEgmMCIState() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmMCIStateImpl);
}

void InitDefaultsEgmRapidCtrlExecStateImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::_EgmRapidCtrlExecState_default_instance_;
    new (ptr) ::abb::egm::EgmRapidCtrlExecState();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmRapidCtrlExecState::InitAsDefaultInstance();
}

void InitDefaultsEgmRapidCtrlExecState() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmRapidCtrlExecStateImpl);
}

void InitDefaultsEgmTestSignalsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::abb::egm::_EgmTestSignals_default_instance_;
    new (ptr) ::abb::egm::EgmTestSignals();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmTestSignals::InitAsDefaultInstance();
}

void InitDefaultsEgmTestSignals() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmTestSignalsImpl);
}

void InitDefaultsEgmRobotImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_2eproto::InitDefaultsEgmHeader();
  protobuf_egm_2eproto::InitDefaultsEgmFeedBack();
  protobuf_egm_2eproto::InitDefaultsEgmPlanned();
  protobuf_egm_2eproto::InitDefaultsEgmMotorState();
  protobuf_egm_2eproto::InitDefaultsEgmMCIState();
  protobuf_egm_2eproto::InitDefaultsEgmTestSignals();
  protobuf_egm_2eproto::InitDefaultsEgmRapidCtrlExecState();
  {
    void* ptr = &::abb::egm::_EgmRobot_default_instance_;
    new (ptr) ::abb::egm::EgmRobot();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmRobot::InitAsDefaultInstance();
}

void InitDefaultsEgmRobot() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmRobotImpl);
}

void InitDefaultsEgmSensorImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_2eproto::InitDefaultsEgmHeader();
  protobuf_egm_2eproto::InitDefaultsEgmPlanned();
  protobuf_egm_2eproto::InitDefaultsEgmSpeedRef();
  {
    void* ptr = &::abb::egm::_EgmSensor_default_instance_;
    new (ptr) ::abb::egm::EgmSensor();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmSensor::InitAsDefaultInstance();
}

void InitDefaultsEgmSensor() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmSensorImpl);
}

void InitDefaultsEgmSensorPathCorrImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_egm_2eproto::InitDefaultsEgmHeader();
  protobuf_egm_2eproto::InitDefaultsEgmPathCorr();
  {
    void* ptr = &::abb::egm::_EgmSensorPathCorr_default_instance_;
    new (ptr) ::abb::egm::EgmSensorPathCorr();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::EgmSensorPathCorr::InitAsDefaultInstance();
}

void InitDefaultsEgmSensorPathCorr() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEgmSensorPathCorrImpl);
}

::google::protobuf::Metadata file_level_metadata[19];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[4];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmHeader, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmHeader, seqno_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmHeader, tm_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmHeader, mtype_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmCartesian, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmCartesian, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmCartesian, x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmCartesian, y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmCartesian, z_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmQuaternion, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmQuaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmQuaternion, u0_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmQuaternion, u1_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmQuaternion, u2_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmQuaternion, u3_),
  0,
  1,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmEuler, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmEuler, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmEuler, x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmEuler, y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmEuler, z_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPose, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPose, pos_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPose, orient_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPose, euler_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmCartesianSpeed, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmCartesianSpeed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmCartesianSpeed, value_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmJoints, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmJoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmJoints, joints_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmExternalJoints, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmExternalJoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmExternalJoints, joints_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPlanned, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPlanned, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPlanned, joints_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPlanned, cartesian_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPlanned, externaljoints_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSpeedRef, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSpeedRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSpeedRef, joints_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSpeedRef, cartesians_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSpeedRef, externaljoints_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPathCorr, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPathCorr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPathCorr, pos_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmPathCorr, age_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmFeedBack, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmFeedBack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmFeedBack, joints_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmFeedBack, cartesian_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmFeedBack, externaljoints_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmMotorState, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmMotorState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmMotorState, state_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmMCIState, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmMCIState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmMCIState, state_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRapidCtrlExecState, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRapidCtrlExecState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRapidCtrlExecState, state_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmTestSignals, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmTestSignals, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmTestSignals, signals_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRobot, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRobot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRobot, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRobot, feedback_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRobot, planned_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRobot, motorstate_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRobot, mcistate_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRobot, mciconvergencemet_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRobot, testsignals_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmRobot, rapidexecstate_),
  0,
  1,
  2,
  3,
  4,
  7,
  5,
  6,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSensor, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSensor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSensor, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSensor, planned_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSensor, speedref_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSensorPathCorr, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSensorPathCorr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSensorPathCorr, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::abb::egm::EgmSensorPathCorr, pathcorr_),
  0,
  1,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::abb::egm::EgmHeader)},
  { 11, 19, sizeof(::abb::egm::EgmCartesian)},
  { 22, 31, sizeof(::abb::egm::EgmQuaternion)},
  { 35, 43, sizeof(::abb::egm::EgmEuler)},
  { 46, 54, sizeof(::abb::egm::EgmPose)},
  { 57, 63, sizeof(::abb::egm::EgmCartesianSpeed)},
  { 64, 70, sizeof(::abb::egm::EgmJoints)},
  { 71, 77, sizeof(::abb::egm::EgmExternalJoints)},
  { 78, 86, sizeof(::abb::egm::EgmPlanned)},
  { 89, 97, sizeof(::abb::egm::EgmSpeedRef)},
  { 100, 107, sizeof(::abb::egm::EgmPathCorr)},
  { 109, 117, sizeof(::abb::egm::EgmFeedBack)},
  { 120, 126, sizeof(::abb::egm::EgmMotorState)},
  { 127, 133, sizeof(::abb::egm::EgmMCIState)},
  { 134, 140, sizeof(::abb::egm::EgmRapidCtrlExecState)},
  { 141, 147, sizeof(::abb::egm::EgmTestSignals)},
  { 148, 161, sizeof(::abb::egm::EgmRobot)},
  { 169, 177, sizeof(::abb::egm::EgmSensor)},
  { 180, 187, sizeof(::abb::egm::EgmSensorPathCorr)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmHeader_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmCartesian_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmQuaternion_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmEuler_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmPose_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmCartesianSpeed_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmJoints_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmExternalJoints_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmPlanned_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmSpeedRef_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmPathCorr_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmFeedBack_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmMotorState_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmMCIState_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmRapidCtrlExecState_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmTestSignals_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmRobot_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmSensor_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::_EgmSensorPathCorr_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "egm.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 19);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\tegm.proto\022\007abb.egm\"\353\001\n\tEgmHeader\022\r\n\005se"
      "qno\030\001 \001(\r\022\n\n\002tm\030\002 \001(\r\022@\n\005mtype\030\003 \001(\0162\036.a"
      "bb.egm.EgmHeader.MessageType:\021MSGTYPE_UN"
      "DEFINED\"\200\001\n\013MessageType\022\025\n\021MSGTYPE_UNDEF"
      "INED\020\000\022\023\n\017MSGTYPE_COMMAND\020\001\022\020\n\014MSGTYPE_D"
      "ATA\020\002\022\026\n\022MSGTYPE_CORRECTION\020\003\022\033\n\027MSGTYPE"
      "_PATH_CORRECTION\020\004\"/\n\014EgmCartesian\022\t\n\001x\030"
      "\001 \002(\001\022\t\n\001y\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"\?\n\rEgmQuater"
      "nion\022\n\n\002u0\030\001 \002(\001\022\n\n\002u1\030\002 \002(\001\022\n\n\002u2\030\003 \002(\001"
      "\022\n\n\002u3\030\004 \002(\001\"+\n\010EgmEuler\022\t\n\001x\030\001 \002(\001\022\t\n\001y"
      "\030\002 \002(\001\022\t\n\001z\030\003 \002(\001\"w\n\007EgmPose\022\"\n\003pos\030\001 \001("
      "\0132\025.abb.egm.EgmCartesian\022&\n\006orient\030\002 \001(\013"
      "2\026.abb.egm.EgmQuaternion\022 \n\005euler\030\003 \001(\0132"
      "\021.abb.egm.EgmEuler\"\"\n\021EgmCartesianSpeed\022"
      "\r\n\005value\030\001 \003(\001\"\033\n\tEgmJoints\022\016\n\006joints\030\001 "
      "\003(\001\"#\n\021EgmExternalJoints\022\016\n\006joints\030\001 \003(\001"
      "\"\201\001\n\nEgmPlanned\022\"\n\006joints\030\001 \001(\0132\022.abb.eg"
      "m.EgmJoints\022#\n\tcartesian\030\002 \001(\0132\020.abb.egm"
      ".EgmPose\022*\n\016externalJoints\030\003 \001(\0132\022.abb.e"
      "gm.EgmJoints\"\215\001\n\013EgmSpeedRef\022\"\n\006joints\030\001"
      " \001(\0132\022.abb.egm.EgmJoints\022.\n\ncartesians\030\002"
      " \001(\0132\032.abb.egm.EgmCartesianSpeed\022*\n\016exte"
      "rnalJoints\030\003 \001(\0132\022.abb.egm.EgmJoints\">\n\013"
      "EgmPathCorr\022\"\n\003pos\030\001 \002(\0132\025.abb.egm.EgmCa"
      "rtesian\022\013\n\003age\030\002 \002(\r\"\202\001\n\013EgmFeedBack\022\"\n\006"
      "joints\030\001 \001(\0132\022.abb.egm.EgmJoints\022#\n\tcart"
      "esian\030\002 \001(\0132\020.abb.egm.EgmPose\022*\n\016externa"
      "lJoints\030\003 \001(\0132\022.abb.egm.EgmJoints\"\214\001\n\rEg"
      "mMotorState\0224\n\005state\030\001 \002(\0162%.abb.egm.Egm"
      "MotorState.MotorStateType\"E\n\016MotorStateT"
      "ype\022\024\n\020MOTORS_UNDEFINED\020\000\022\r\n\tMOTORS_ON\020\001"
      "\022\016\n\nMOTORS_OFF\020\002\"\242\001\n\013EgmMCIState\022\?\n\005stat"
      "e\030\001 \002(\0162!.abb.egm.EgmMCIState.MCIStateTy"
      "pe:\rMCI_UNDEFINED\"R\n\014MCIStateType\022\021\n\rMCI"
      "_UNDEFINED\020\000\022\r\n\tMCI_ERROR\020\001\022\017\n\013MCI_STOPP"
      "ED\020\002\022\017\n\013MCI_RUNNING\020\003\"\303\001\n\025EgmRapidCtrlEx"
      "ecState\022U\n\005state\030\001 \002(\01625.abb.egm.EgmRapi"
      "dCtrlExecState.RapidCtrlExecStateType:\017R"
      "APID_UNDEFINED\"S\n\026RapidCtrlExecStateType"
      "\022\023\n\017RAPID_UNDEFINED\020\000\022\021\n\rRAPID_STOPPED\020\001"
      "\022\021\n\rRAPID_RUNNING\020\002\"!\n\016EgmTestSignals\022\017\n"
      "\007signals\030\001 \003(\001\"\321\002\n\010EgmRobot\022\"\n\006header\030\001 "
      "\001(\0132\022.abb.egm.EgmHeader\022&\n\010feedBack\030\002 \001("
      "\0132\024.abb.egm.EgmFeedBack\022$\n\007planned\030\003 \001(\013"
      "2\023.abb.egm.EgmPlanned\022*\n\nmotorState\030\004 \001("
      "\0132\026.abb.egm.EgmMotorState\022&\n\010mciState\030\005 "
      "\001(\0132\024.abb.egm.EgmMCIState\022\031\n\021mciConverge"
      "nceMet\030\006 \001(\010\022,\n\013testSignals\030\007 \001(\0132\027.abb."
      "egm.EgmTestSignals\0226\n\016rapidExecState\030\010 \001"
      "(\0132\036.abb.egm.EgmRapidCtrlExecState\"}\n\tEg"
      "mSensor\022\"\n\006header\030\001 \001(\0132\022.abb.egm.EgmHea"
      "der\022$\n\007planned\030\002 \001(\0132\023.abb.egm.EgmPlanne"
      "d\022&\n\010speedRef\030\003 \001(\0132\024.abb.egm.EgmSpeedRe"
      "f\"_\n\021EgmSensorPathCorr\022\"\n\006header\030\001 \001(\0132\022"
      ".abb.egm.EgmHeader\022&\n\010pathCorr\030\002 \001(\0132\024.a"
      "bb.egm.EgmPathCorr"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 2218);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "egm.proto", &protobuf_RegisterTypes);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_egm_2eproto
namespace abb {
namespace egm {
const ::google::protobuf::EnumDescriptor* EgmHeader_MessageType_descriptor() {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_2eproto::file_level_enum_descriptors[0];
}
bool EgmHeader_MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const EgmHeader_MessageType EgmHeader::MSGTYPE_UNDEFINED;
const EgmHeader_MessageType EgmHeader::MSGTYPE_COMMAND;
const EgmHeader_MessageType EgmHeader::MSGTYPE_DATA;
const EgmHeader_MessageType EgmHeader::MSGTYPE_CORRECTION;
const EgmHeader_MessageType EgmHeader::MSGTYPE_PATH_CORRECTION;
const EgmHeader_MessageType EgmHeader::MessageType_MIN;
const EgmHeader_MessageType EgmHeader::MessageType_MAX;
const int EgmHeader::MessageType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* EgmMotorState_MotorStateType_descriptor() {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_2eproto::file_level_enum_descriptors[1];
}
bool EgmMotorState_MotorStateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const EgmMotorState_MotorStateType EgmMotorState::MOTORS_UNDEFINED;
const EgmMotorState_MotorStateType EgmMotorState::MOTORS_ON;
const EgmMotorState_MotorStateType EgmMotorState::MOTORS_OFF;
const EgmMotorState_MotorStateType EgmMotorState::MotorStateType_MIN;
const EgmMotorState_MotorStateType EgmMotorState::MotorStateType_MAX;
const int EgmMotorState::MotorStateType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* EgmMCIState_MCIStateType_descriptor() {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_2eproto::file_level_enum_descriptors[2];
}
bool EgmMCIState_MCIStateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const EgmMCIState_MCIStateType EgmMCIState::MCI_UNDEFINED;
const EgmMCIState_MCIStateType EgmMCIState::MCI_ERROR;
const EgmMCIState_MCIStateType EgmMCIState::MCI_STOPPED;
const EgmMCIState_MCIStateType EgmMCIState::MCI_RUNNING;
const EgmMCIState_MCIStateType EgmMCIState::MCIStateType_MIN;
const EgmMCIState_MCIStateType EgmMCIState::MCIStateType_MAX;
const int EgmMCIState::MCIStateType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* EgmRapidCtrlExecState_RapidCtrlExecStateType_descriptor() {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_egm_2eproto::file_level_enum_descriptors[3];
}
bool EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RAPID_UNDEFINED;
const EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RAPID_STOPPED;
const EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RAPID_RUNNING;
const EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RapidCtrlExecStateType_MIN;
const EgmRapidCtrlExecState_RapidCtrlExecStateType EgmRapidCtrlExecState::RapidCtrlExecStateType_MAX;
const int EgmRapidCtrlExecState::RapidCtrlExecStateType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

void EgmHeader::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmHeader::kSeqnoFieldNumber;
const int EgmHeader::kTmFieldNumber;
const int EgmHeader::kMtypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmHeader::EgmHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmHeader();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmHeader)
}
EgmHeader::EgmHeader(const EgmHeader& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&seqno_, &from.seqno_,
    static_cast<size_t>(reinterpret_cast<char*>(&mtype_) -
    reinterpret_cast<char*>(&seqno_)) + sizeof(mtype_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmHeader)
}

void EgmHeader::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&seqno_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mtype_) -
      reinterpret_cast<char*>(&seqno_)) + sizeof(mtype_));
}

EgmHeader::~EgmHeader() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmHeader)
  SharedDtor();
}

void EgmHeader::SharedDtor() {
}

void EgmHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmHeader::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmHeader& EgmHeader::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmHeader();
  return *internal_default_instance();
}

EgmHeader* EgmHeader::New(::google::protobuf::Arena* arena) const {
  EgmHeader* n = new EgmHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmHeader)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    ::memset(&seqno_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mtype_) -
        reinterpret_cast<char*>(&seqno_)) + sizeof(mtype_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 seqno = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_seqno();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seqno_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 tm = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_tm();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tm_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::EgmHeader_MessageType_IsValid(value)) {
            set_mtype(static_cast< ::abb::egm::EgmHeader_MessageType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmHeader)
  return false;
#undef DO_
}

void EgmHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmHeader)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 seqno = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->seqno(), output);
  }

  // optional uint32 tm = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->tm(), output);
  }

  // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->mtype(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmHeader)
}

::google::protobuf::uint8* EgmHeader::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmHeader)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 seqno = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->seqno(), target);
  }

  // optional uint32 tm = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->tm(), target);
  }

  // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->mtype(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmHeader)
  return target;
}

size_t EgmHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmHeader)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional uint32 seqno = 1;
    if (has_seqno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seqno());
    }

    // optional uint32 tm = 2;
    if (has_tm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tm());
    }

    // optional .abb.egm.EgmHeader.MessageType mtype = 3 [default = MSGTYPE_UNDEFINED];
    if (has_mtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mtype());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmHeader::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmHeader)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmHeader* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmHeader>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmHeader)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmHeader)
    MergeFrom(*source);
  }
}

void EgmHeader::MergeFrom(const EgmHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmHeader)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      seqno_ = from.seqno_;
    }
    if (cached_has_bits & 0x00000002u) {
      tm_ = from.tm_;
    }
    if (cached_has_bits & 0x00000004u) {
      mtype_ = from.mtype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmHeader::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmHeader::CopyFrom(const EgmHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmHeader::IsInitialized() const {
  return true;
}

void EgmHeader::Swap(EgmHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmHeader::InternalSwap(EgmHeader* other) {
  using std::swap;
  swap(seqno_, other->seqno_);
  swap(tm_, other->tm_);
  swap(mtype_, other->mtype_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmHeader::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmCartesian::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmCartesian::kXFieldNumber;
const int EgmCartesian::kYFieldNumber;
const int EgmCartesian::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmCartesian::EgmCartesian()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmCartesian();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmCartesian)
}
EgmCartesian::EgmCartesian(const EgmCartesian& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmCartesian)
}

void EgmCartesian::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

EgmCartesian::~EgmCartesian() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmCartesian)
  SharedDtor();
}

void EgmCartesian::SharedDtor() {
}

void EgmCartesian::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmCartesian::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmCartesian& EgmCartesian::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmCartesian();
  return *internal_default_instance();
}

EgmCartesian* EgmCartesian::New(::google::protobuf::Arena* arena) const {
  EgmCartesian* n = new EgmCartesian;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmCartesian::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmCartesian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmCartesian::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmCartesian)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          set_has_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u /* 17 & 0xFF */)) {
          set_has_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required double z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u /* 25 & 0xFF */)) {
          set_has_z();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmCartesian)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmCartesian)
  return false;
#undef DO_
}

void EgmCartesian::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmCartesian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required double y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // required double z = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmCartesian)
}

::google::protobuf::uint8* EgmCartesian::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmCartesian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // required double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmCartesian)
  return target;
}

size_t EgmCartesian::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmCartesian)
  size_t total_size = 0;

  if (has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t EgmCartesian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmCartesian)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmCartesian::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmCartesian)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmCartesian* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmCartesian>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmCartesian)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmCartesian)
    MergeFrom(*source);
  }
}

void EgmCartesian::MergeFrom(const EgmCartesian& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmCartesian)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmCartesian::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmCartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmCartesian::CopyFrom(const EgmCartesian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmCartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmCartesian::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void EgmCartesian::Swap(EgmCartesian* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmCartesian::InternalSwap(EgmCartesian* other) {
  using std::swap;
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmCartesian::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmQuaternion::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmQuaternion::kU0FieldNumber;
const int EgmQuaternion::kU1FieldNumber;
const int EgmQuaternion::kU2FieldNumber;
const int EgmQuaternion::kU3FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmQuaternion::EgmQuaternion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmQuaternion();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmQuaternion)
}
EgmQuaternion::EgmQuaternion(const EgmQuaternion& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&u0_, &from.u0_,
    static_cast<size_t>(reinterpret_cast<char*>(&u3_) -
    reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmQuaternion)
}

void EgmQuaternion::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&u0_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&u3_) -
      reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
}

EgmQuaternion::~EgmQuaternion() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmQuaternion)
  SharedDtor();
}

void EgmQuaternion::SharedDtor() {
}

void EgmQuaternion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmQuaternion::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmQuaternion& EgmQuaternion::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmQuaternion();
  return *internal_default_instance();
}

EgmQuaternion* EgmQuaternion::New(::google::protobuf::Arena* arena) const {
  EgmQuaternion* n = new EgmQuaternion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmQuaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmQuaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    ::memset(&u0_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&u3_) -
        reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmQuaternion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmQuaternion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double u0 = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          set_has_u0();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u0_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required double u1 = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u /* 17 & 0xFF */)) {
          set_has_u1();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required double u2 = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u /* 25 & 0xFF */)) {
          set_has_u2();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required double u3 = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(33u /* 33 & 0xFF */)) {
          set_has_u3();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmQuaternion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmQuaternion)
  return false;
#undef DO_
}

void EgmQuaternion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmQuaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double u0 = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->u0(), output);
  }

  // required double u1 = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->u1(), output);
  }

  // required double u2 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->u2(), output);
  }

  // required double u3 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->u3(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmQuaternion)
}

::google::protobuf::uint8* EgmQuaternion::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmQuaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double u0 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->u0(), target);
  }

  // required double u1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->u1(), target);
  }

  // required double u2 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->u2(), target);
  }

  // required double u3 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->u3(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmQuaternion)
  return target;
}

size_t EgmQuaternion::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmQuaternion)
  size_t total_size = 0;

  if (has_u0()) {
    // required double u0 = 1;
    total_size += 1 + 8;
  }

  if (has_u1()) {
    // required double u1 = 2;
    total_size += 1 + 8;
  }

  if (has_u2()) {
    // required double u2 = 3;
    total_size += 1 + 8;
  }

  if (has_u3()) {
    // required double u3 = 4;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t EgmQuaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmQuaternion)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double u0 = 1;
    total_size += 1 + 8;

    // required double u1 = 2;
    total_size += 1 + 8;

    // required double u2 = 3;
    total_size += 1 + 8;

    // required double u3 = 4;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmQuaternion::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmQuaternion)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmQuaternion* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmQuaternion>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmQuaternion)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmQuaternion)
    MergeFrom(*source);
  }
}

void EgmQuaternion::MergeFrom(const EgmQuaternion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmQuaternion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      u0_ = from.u0_;
    }
    if (cached_has_bits & 0x00000002u) {
      u1_ = from.u1_;
    }
    if (cached_has_bits & 0x00000004u) {
      u2_ = from.u2_;
    }
    if (cached_has_bits & 0x00000008u) {
      u3_ = from.u3_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmQuaternion::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmQuaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmQuaternion::CopyFrom(const EgmQuaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmQuaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmQuaternion::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  return true;
}

void EgmQuaternion::Swap(EgmQuaternion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmQuaternion::InternalSwap(EgmQuaternion* other) {
  using std::swap;
  swap(u0_, other->u0_);
  swap(u1_, other->u1_);
  swap(u2_, other->u2_);
  swap(u3_, other->u3_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmQuaternion::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmEuler::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmEuler::kXFieldNumber;
const int EgmEuler::kYFieldNumber;
const int EgmEuler::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmEuler::EgmEuler()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmEuler();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmEuler)
}
EgmEuler::EgmEuler(const EgmEuler& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmEuler)
}

void EgmEuler::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

EgmEuler::~EgmEuler() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmEuler)
  SharedDtor();
}

void EgmEuler::SharedDtor() {
}

void EgmEuler::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmEuler::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmEuler& EgmEuler::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmEuler();
  return *internal_default_instance();
}

EgmEuler* EgmEuler::New(::google::protobuf::Arena* arena) const {
  EgmEuler* n = new EgmEuler;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmEuler::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmEuler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmEuler::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmEuler)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          set_has_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(17u /* 17 & 0xFF */)) {
          set_has_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required double z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(25u /* 25 & 0xFF */)) {
          set_has_z();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmEuler)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmEuler)
  return false;
#undef DO_
}

void EgmEuler::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmEuler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // required double y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // required double z = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmEuler)
}

::google::protobuf::uint8* EgmEuler::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmEuler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // required double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // required double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmEuler)
  return target;
}

size_t EgmEuler::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmEuler)
  size_t total_size = 0;

  if (has_x()) {
    // required double x = 1;
    total_size += 1 + 8;
  }

  if (has_y()) {
    // required double y = 2;
    total_size += 1 + 8;
  }

  if (has_z()) {
    // required double z = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t EgmEuler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmEuler)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x = 1;
    total_size += 1 + 8;

    // required double y = 2;
    total_size += 1 + 8;

    // required double z = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmEuler::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmEuler)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmEuler* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmEuler>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmEuler)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmEuler)
    MergeFrom(*source);
  }
}

void EgmEuler::MergeFrom(const EgmEuler& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmEuler)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmEuler::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmEuler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmEuler::CopyFrom(const EgmEuler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmEuler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmEuler::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void EgmEuler::Swap(EgmEuler* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmEuler::InternalSwap(EgmEuler* other) {
  using std::swap;
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmEuler::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmPose::InitAsDefaultInstance() {
  ::abb::egm::_EgmPose_default_instance_._instance.get_mutable()->pos_ = const_cast< ::abb::egm::EgmCartesian*>(
      ::abb::egm::EgmCartesian::internal_default_instance());
  ::abb::egm::_EgmPose_default_instance_._instance.get_mutable()->orient_ = const_cast< ::abb::egm::EgmQuaternion*>(
      ::abb::egm::EgmQuaternion::internal_default_instance());
  ::abb::egm::_EgmPose_default_instance_._instance.get_mutable()->euler_ = const_cast< ::abb::egm::EgmEuler*>(
      ::abb::egm::EgmEuler::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmPose::kPosFieldNumber;
const int EgmPose::kOrientFieldNumber;
const int EgmPose::kEulerFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmPose::EgmPose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmPose();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmPose)
}
EgmPose::EgmPose(const EgmPose& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_pos()) {
    pos_ = new ::abb::egm::EgmCartesian(*from.pos_);
  } else {
    pos_ = NULL;
  }
  if (from.has_orient()) {
    orient_ = new ::abb::egm::EgmQuaternion(*from.orient_);
  } else {
    orient_ = NULL;
  }
  if (from.has_euler()) {
    euler_ = new ::abb::egm::EgmEuler(*from.euler_);
  } else {
    euler_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmPose)
}

void EgmPose::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&euler_) -
      reinterpret_cast<char*>(&pos_)) + sizeof(euler_));
}

EgmPose::~EgmPose() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmPose)
  SharedDtor();
}

void EgmPose::SharedDtor() {
  if (this != internal_default_instance()) delete pos_;
  if (this != internal_default_instance()) delete orient_;
  if (this != internal_default_instance()) delete euler_;
}

void EgmPose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmPose::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmPose& EgmPose::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmPose();
  return *internal_default_instance();
}

EgmPose* EgmPose::New(::google::protobuf::Arena* arena) const {
  EgmPose* n = new EgmPose;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmPose::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmPose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(pos_ != NULL);
      pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(orient_ != NULL);
      orient_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(euler_ != NULL);
      euler_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmPose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmPose)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmCartesian pos = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmQuaternion orient = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_orient()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmEuler euler = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_euler()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmPose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmPose)
  return false;
#undef DO_
}

void EgmPose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmPose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmCartesian pos = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->pos_, output);
  }

  // optional .abb.egm.EgmQuaternion orient = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->orient_, output);
  }

  // optional .abb.egm.EgmEuler euler = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->euler_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmPose)
}

::google::protobuf::uint8* EgmPose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmPose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmCartesian pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->pos_, deterministic, target);
  }

  // optional .abb.egm.EgmQuaternion orient = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->orient_, deterministic, target);
  }

  // optional .abb.egm.EgmEuler euler = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->euler_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmPose)
  return target;
}

size_t EgmPose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmPose)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .abb.egm.EgmCartesian pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->pos_);
    }

    // optional .abb.egm.EgmQuaternion orient = 2;
    if (has_orient()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->orient_);
    }

    // optional .abb.egm.EgmEuler euler = 3;
    if (has_euler()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->euler_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmPose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmPose)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmPose* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmPose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmPose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmPose)
    MergeFrom(*source);
  }
}

void EgmPose::MergeFrom(const EgmPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmPose)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_pos()->::abb::egm::EgmCartesian::MergeFrom(from.pos());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_orient()->::abb::egm::EgmQuaternion::MergeFrom(from.orient());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_euler()->::abb::egm::EgmEuler::MergeFrom(from.euler());
    }
  }
}

void EgmPose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmPose::CopyFrom(const EgmPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmPose::IsInitialized() const {
  if (has_pos()) {
    if (!this->pos_->IsInitialized()) return false;
  }
  if (has_orient()) {
    if (!this->orient_->IsInitialized()) return false;
  }
  if (has_euler()) {
    if (!this->euler_->IsInitialized()) return false;
  }
  return true;
}

void EgmPose::Swap(EgmPose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmPose::InternalSwap(EgmPose* other) {
  using std::swap;
  swap(pos_, other->pos_);
  swap(orient_, other->orient_);
  swap(euler_, other->euler_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmPose::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmCartesianSpeed::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmCartesianSpeed::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmCartesianSpeed::EgmCartesianSpeed()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmCartesianSpeed();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmCartesianSpeed)
}
EgmCartesianSpeed::EgmCartesianSpeed(const EgmCartesianSpeed& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      value_(from.value_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmCartesianSpeed)
}

void EgmCartesianSpeed::SharedCtor() {
  _cached_size_ = 0;
}

EgmCartesianSpeed::~EgmCartesianSpeed() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmCartesianSpeed)
  SharedDtor();
}

void EgmCartesianSpeed::SharedDtor() {
}

void EgmCartesianSpeed::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmCartesianSpeed::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmCartesianSpeed& EgmCartesianSpeed::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmCartesianSpeed();
  return *internal_default_instance();
}

EgmCartesianSpeed* EgmCartesianSpeed::New(::google::protobuf::Arena* arena) const {
  EgmCartesianSpeed* n = new EgmCartesianSpeed;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmCartesianSpeed::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmCartesianSpeed)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmCartesianSpeed::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmCartesianSpeed)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double value = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9u, input, this->mutable_value())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_value())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmCartesianSpeed)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmCartesianSpeed)
  return false;
#undef DO_
}

void EgmCartesianSpeed::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmCartesianSpeed)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double value = 1;
  for (int i = 0, n = this->value_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->value(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmCartesianSpeed)
}

::google::protobuf::uint8* EgmCartesianSpeed::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmCartesianSpeed)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double value = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(1, this->value_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmCartesianSpeed)
  return target;
}

size_t EgmCartesianSpeed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmCartesianSpeed)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated double value = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->value_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->value_size());
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmCartesianSpeed::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmCartesianSpeed)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmCartesianSpeed* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmCartesianSpeed>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmCartesianSpeed)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmCartesianSpeed)
    MergeFrom(*source);
  }
}

void EgmCartesianSpeed::MergeFrom(const EgmCartesianSpeed& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmCartesianSpeed)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  value_.MergeFrom(from.value_);
}

void EgmCartesianSpeed::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmCartesianSpeed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmCartesianSpeed::CopyFrom(const EgmCartesianSpeed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmCartesianSpeed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmCartesianSpeed::IsInitialized() const {
  return true;
}

void EgmCartesianSpeed::Swap(EgmCartesianSpeed* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmCartesianSpeed::InternalSwap(EgmCartesianSpeed* other) {
  using std::swap;
  value_.InternalSwap(&other->value_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmCartesianSpeed::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmJoints::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmJoints::kJointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmJoints::EgmJoints()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmJoints();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmJoints)
}
EgmJoints::EgmJoints(const EgmJoints& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      joints_(from.joints_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmJoints)
}

void EgmJoints::SharedCtor() {
  _cached_size_ = 0;
}

EgmJoints::~EgmJoints() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmJoints)
  SharedDtor();
}

void EgmJoints::SharedDtor() {
}

void EgmJoints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmJoints::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmJoints& EgmJoints::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmJoints();
  return *internal_default_instance();
}

EgmJoints* EgmJoints::New(::google::protobuf::Arena* arena) const {
  EgmJoints* n = new EgmJoints;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmJoints::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmJoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  joints_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmJoints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmJoints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double joints = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9u, input, this->mutable_joints())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_joints())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmJoints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmJoints)
  return false;
#undef DO_
}

void EgmJoints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmJoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double joints = 1;
  for (int i = 0, n = this->joints_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->joints(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmJoints)
}

::google::protobuf::uint8* EgmJoints::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmJoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double joints = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(1, this->joints_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmJoints)
  return target;
}

size_t EgmJoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmJoints)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated double joints = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->joints_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->joints_size());
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmJoints::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmJoints)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmJoints* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmJoints>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmJoints)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmJoints)
    MergeFrom(*source);
  }
}

void EgmJoints::MergeFrom(const EgmJoints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmJoints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  joints_.MergeFrom(from.joints_);
}

void EgmJoints::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmJoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmJoints::CopyFrom(const EgmJoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmJoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmJoints::IsInitialized() const {
  return true;
}

void EgmJoints::Swap(EgmJoints* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmJoints::InternalSwap(EgmJoints* other) {
  using std::swap;
  joints_.InternalSwap(&other->joints_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmJoints::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmExternalJoints::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmExternalJoints::kJointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmExternalJoints::EgmExternalJoints()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmExternalJoints();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmExternalJoints)
}
EgmExternalJoints::EgmExternalJoints(const EgmExternalJoints& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      joints_(from.joints_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmExternalJoints)
}

void EgmExternalJoints::SharedCtor() {
  _cached_size_ = 0;
}

EgmExternalJoints::~EgmExternalJoints() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmExternalJoints)
  SharedDtor();
}

void EgmExternalJoints::SharedDtor() {
}

void EgmExternalJoints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmExternalJoints::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmExternalJoints& EgmExternalJoints::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmExternalJoints();
  return *internal_default_instance();
}

EgmExternalJoints* EgmExternalJoints::New(::google::protobuf::Arena* arena) const {
  EgmExternalJoints* n = new EgmExternalJoints;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmExternalJoints::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmExternalJoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  joints_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmExternalJoints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmExternalJoints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double joints = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9u, input, this->mutable_joints())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_joints())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmExternalJoints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmExternalJoints)
  return false;
#undef DO_
}

void EgmExternalJoints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmExternalJoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double joints = 1;
  for (int i = 0, n = this->joints_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->joints(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmExternalJoints)
}

::google::protobuf::uint8* EgmExternalJoints::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmExternalJoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double joints = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(1, this->joints_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmExternalJoints)
  return target;
}

size_t EgmExternalJoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmExternalJoints)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated double joints = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->joints_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->joints_size());
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmExternalJoints::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmExternalJoints)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmExternalJoints* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmExternalJoints>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmExternalJoints)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmExternalJoints)
    MergeFrom(*source);
  }
}

void EgmExternalJoints::MergeFrom(const EgmExternalJoints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmExternalJoints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  joints_.MergeFrom(from.joints_);
}

void EgmExternalJoints::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmExternalJoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmExternalJoints::CopyFrom(const EgmExternalJoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmExternalJoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmExternalJoints::IsInitialized() const {
  return true;
}

void EgmExternalJoints::Swap(EgmExternalJoints* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmExternalJoints::InternalSwap(EgmExternalJoints* other) {
  using std::swap;
  joints_.InternalSwap(&other->joints_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmExternalJoints::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmPlanned::InitAsDefaultInstance() {
  ::abb::egm::_EgmPlanned_default_instance_._instance.get_mutable()->joints_ = const_cast< ::abb::egm::EgmJoints*>(
      ::abb::egm::EgmJoints::internal_default_instance());
  ::abb::egm::_EgmPlanned_default_instance_._instance.get_mutable()->cartesian_ = const_cast< ::abb::egm::EgmPose*>(
      ::abb::egm::EgmPose::internal_default_instance());
  ::abb::egm::_EgmPlanned_default_instance_._instance.get_mutable()->externaljoints_ = const_cast< ::abb::egm::EgmJoints*>(
      ::abb::egm::EgmJoints::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmPlanned::kJointsFieldNumber;
const int EgmPlanned::kCartesianFieldNumber;
const int EgmPlanned::kExternalJointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmPlanned::EgmPlanned()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmPlanned();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmPlanned)
}
EgmPlanned::EgmPlanned(const EgmPlanned& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_joints()) {
    joints_ = new ::abb::egm::EgmJoints(*from.joints_);
  } else {
    joints_ = NULL;
  }
  if (from.has_cartesian()) {
    cartesian_ = new ::abb::egm::EgmPose(*from.cartesian_);
  } else {
    cartesian_ = NULL;
  }
  if (from.has_externaljoints()) {
    externaljoints_ = new ::abb::egm::EgmJoints(*from.externaljoints_);
  } else {
    externaljoints_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmPlanned)
}

void EgmPlanned::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&joints_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&externaljoints_) -
      reinterpret_cast<char*>(&joints_)) + sizeof(externaljoints_));
}

EgmPlanned::~EgmPlanned() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmPlanned)
  SharedDtor();
}

void EgmPlanned::SharedDtor() {
  if (this != internal_default_instance()) delete joints_;
  if (this != internal_default_instance()) delete cartesian_;
  if (this != internal_default_instance()) delete externaljoints_;
}

void EgmPlanned::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmPlanned::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmPlanned& EgmPlanned::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmPlanned();
  return *internal_default_instance();
}

EgmPlanned* EgmPlanned::New(::google::protobuf::Arena* arena) const {
  EgmPlanned* n = new EgmPlanned;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmPlanned::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmPlanned)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(joints_ != NULL);
      joints_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(cartesian_ != NULL);
      cartesian_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(externaljoints_ != NULL);
      externaljoints_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmPlanned::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmPlanned)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmJoints joints = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmPose cartesian = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_cartesian()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmJoints externalJoints = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_externaljoints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmPlanned)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmPlanned)
  return false;
#undef DO_
}

void EgmPlanned::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmPlanned)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmJoints joints = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->joints_, output);
  }

  // optional .abb.egm.EgmPose cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->cartesian_, output);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->externaljoints_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmPlanned)
}

::google::protobuf::uint8* EgmPlanned::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmPlanned)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmJoints joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->joints_, deterministic, target);
  }

  // optional .abb.egm.EgmPose cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->cartesian_, deterministic, target);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->externaljoints_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmPlanned)
  return target;
}

size_t EgmPlanned::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmPlanned)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .abb.egm.EgmJoints joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->joints_);
    }

    // optional .abb.egm.EgmPose cartesian = 2;
    if (has_cartesian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->cartesian_);
    }

    // optional .abb.egm.EgmJoints externalJoints = 3;
    if (has_externaljoints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->externaljoints_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmPlanned::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmPlanned)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmPlanned* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmPlanned>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmPlanned)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmPlanned)
    MergeFrom(*source);
  }
}

void EgmPlanned::MergeFrom(const EgmPlanned& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmPlanned)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_joints()->::abb::egm::EgmJoints::MergeFrom(from.joints());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_cartesian()->::abb::egm::EgmPose::MergeFrom(from.cartesian());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_externaljoints()->::abb::egm::EgmJoints::MergeFrom(from.externaljoints());
    }
  }
}

void EgmPlanned::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmPlanned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmPlanned::CopyFrom(const EgmPlanned& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmPlanned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmPlanned::IsInitialized() const {
  if (has_cartesian()) {
    if (!this->cartesian_->IsInitialized()) return false;
  }
  return true;
}

void EgmPlanned::Swap(EgmPlanned* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmPlanned::InternalSwap(EgmPlanned* other) {
  using std::swap;
  swap(joints_, other->joints_);
  swap(cartesian_, other->cartesian_);
  swap(externaljoints_, other->externaljoints_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmPlanned::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmSpeedRef::InitAsDefaultInstance() {
  ::abb::egm::_EgmSpeedRef_default_instance_._instance.get_mutable()->joints_ = const_cast< ::abb::egm::EgmJoints*>(
      ::abb::egm::EgmJoints::internal_default_instance());
  ::abb::egm::_EgmSpeedRef_default_instance_._instance.get_mutable()->cartesians_ = const_cast< ::abb::egm::EgmCartesianSpeed*>(
      ::abb::egm::EgmCartesianSpeed::internal_default_instance());
  ::abb::egm::_EgmSpeedRef_default_instance_._instance.get_mutable()->externaljoints_ = const_cast< ::abb::egm::EgmJoints*>(
      ::abb::egm::EgmJoints::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmSpeedRef::kJointsFieldNumber;
const int EgmSpeedRef::kCartesiansFieldNumber;
const int EgmSpeedRef::kExternalJointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmSpeedRef::EgmSpeedRef()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmSpeedRef();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmSpeedRef)
}
EgmSpeedRef::EgmSpeedRef(const EgmSpeedRef& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_joints()) {
    joints_ = new ::abb::egm::EgmJoints(*from.joints_);
  } else {
    joints_ = NULL;
  }
  if (from.has_cartesians()) {
    cartesians_ = new ::abb::egm::EgmCartesianSpeed(*from.cartesians_);
  } else {
    cartesians_ = NULL;
  }
  if (from.has_externaljoints()) {
    externaljoints_ = new ::abb::egm::EgmJoints(*from.externaljoints_);
  } else {
    externaljoints_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmSpeedRef)
}

void EgmSpeedRef::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&joints_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&externaljoints_) -
      reinterpret_cast<char*>(&joints_)) + sizeof(externaljoints_));
}

EgmSpeedRef::~EgmSpeedRef() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmSpeedRef)
  SharedDtor();
}

void EgmSpeedRef::SharedDtor() {
  if (this != internal_default_instance()) delete joints_;
  if (this != internal_default_instance()) delete cartesians_;
  if (this != internal_default_instance()) delete externaljoints_;
}

void EgmSpeedRef::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmSpeedRef::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmSpeedRef& EgmSpeedRef::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmSpeedRef();
  return *internal_default_instance();
}

EgmSpeedRef* EgmSpeedRef::New(::google::protobuf::Arena* arena) const {
  EgmSpeedRef* n = new EgmSpeedRef;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmSpeedRef::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmSpeedRef)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(joints_ != NULL);
      joints_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(cartesians_ != NULL);
      cartesians_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(externaljoints_ != NULL);
      externaljoints_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmSpeedRef::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmSpeedRef)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmJoints joints = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_cartesians()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmJoints externalJoints = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_externaljoints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmSpeedRef)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmSpeedRef)
  return false;
#undef DO_
}

void EgmSpeedRef::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmSpeedRef)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmJoints joints = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->joints_, output);
  }

  // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->cartesians_, output);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->externaljoints_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmSpeedRef)
}

::google::protobuf::uint8* EgmSpeedRef::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmSpeedRef)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmJoints joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->joints_, deterministic, target);
  }

  // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->cartesians_, deterministic, target);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->externaljoints_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmSpeedRef)
  return target;
}

size_t EgmSpeedRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmSpeedRef)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .abb.egm.EgmJoints joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->joints_);
    }

    // optional .abb.egm.EgmCartesianSpeed cartesians = 2;
    if (has_cartesians()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->cartesians_);
    }

    // optional .abb.egm.EgmJoints externalJoints = 3;
    if (has_externaljoints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->externaljoints_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmSpeedRef::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmSpeedRef)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmSpeedRef* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmSpeedRef>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmSpeedRef)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmSpeedRef)
    MergeFrom(*source);
  }
}

void EgmSpeedRef::MergeFrom(const EgmSpeedRef& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmSpeedRef)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_joints()->::abb::egm::EgmJoints::MergeFrom(from.joints());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_cartesians()->::abb::egm::EgmCartesianSpeed::MergeFrom(from.cartesians());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_externaljoints()->::abb::egm::EgmJoints::MergeFrom(from.externaljoints());
    }
  }
}

void EgmSpeedRef::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmSpeedRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmSpeedRef::CopyFrom(const EgmSpeedRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmSpeedRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmSpeedRef::IsInitialized() const {
  return true;
}

void EgmSpeedRef::Swap(EgmSpeedRef* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmSpeedRef::InternalSwap(EgmSpeedRef* other) {
  using std::swap;
  swap(joints_, other->joints_);
  swap(cartesians_, other->cartesians_);
  swap(externaljoints_, other->externaljoints_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmSpeedRef::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmPathCorr::InitAsDefaultInstance() {
  ::abb::egm::_EgmPathCorr_default_instance_._instance.get_mutable()->pos_ = const_cast< ::abb::egm::EgmCartesian*>(
      ::abb::egm::EgmCartesian::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmPathCorr::kPosFieldNumber;
const int EgmPathCorr::kAgeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmPathCorr::EgmPathCorr()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmPathCorr();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmPathCorr)
}
EgmPathCorr::EgmPathCorr(const EgmPathCorr& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_pos()) {
    pos_ = new ::abb::egm::EgmCartesian(*from.pos_);
  } else {
    pos_ = NULL;
  }
  age_ = from.age_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmPathCorr)
}

void EgmPathCorr::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&age_) -
      reinterpret_cast<char*>(&pos_)) + sizeof(age_));
}

EgmPathCorr::~EgmPathCorr() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmPathCorr)
  SharedDtor();
}

void EgmPathCorr::SharedDtor() {
  if (this != internal_default_instance()) delete pos_;
}

void EgmPathCorr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmPathCorr::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmPathCorr& EgmPathCorr::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmPathCorr();
  return *internal_default_instance();
}

EgmPathCorr* EgmPathCorr::New(::google::protobuf::Arena* arena) const {
  EgmPathCorr* n = new EgmPathCorr;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmPathCorr::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmPathCorr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(pos_ != NULL);
    pos_->Clear();
  }
  age_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmPathCorr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmPathCorr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .abb.egm.EgmCartesian pos = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 age = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_age();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &age_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmPathCorr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmPathCorr)
  return false;
#undef DO_
}

void EgmPathCorr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmPathCorr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .abb.egm.EgmCartesian pos = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->pos_, output);
  }

  // required uint32 age = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->age(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmPathCorr)
}

::google::protobuf::uint8* EgmPathCorr::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmPathCorr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .abb.egm.EgmCartesian pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->pos_, deterministic, target);
  }

  // required uint32 age = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->age(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmPathCorr)
  return target;
}

size_t EgmPathCorr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:abb.egm.EgmPathCorr)
  size_t total_size = 0;

  if (has_pos()) {
    // required .abb.egm.EgmCartesian pos = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->pos_);
  }

  if (has_age()) {
    // required uint32 age = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->age());
  }

  return total_size;
}
size_t EgmPathCorr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmPathCorr)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .abb.egm.EgmCartesian pos = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->pos_);

    // required uint32 age = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->age());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmPathCorr::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmPathCorr)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmPathCorr* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmPathCorr>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmPathCorr)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmPathCorr)
    MergeFrom(*source);
  }
}

void EgmPathCorr::MergeFrom(const EgmPathCorr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmPathCorr)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_pos()->::abb::egm::EgmCartesian::MergeFrom(from.pos());
    }
    if (cached_has_bits & 0x00000002u) {
      age_ = from.age_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmPathCorr::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmPathCorr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmPathCorr::CopyFrom(const EgmPathCorr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmPathCorr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmPathCorr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (has_pos()) {
    if (!this->pos_->IsInitialized()) return false;
  }
  return true;
}

void EgmPathCorr::Swap(EgmPathCorr* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmPathCorr::InternalSwap(EgmPathCorr* other) {
  using std::swap;
  swap(pos_, other->pos_);
  swap(age_, other->age_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmPathCorr::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmFeedBack::InitAsDefaultInstance() {
  ::abb::egm::_EgmFeedBack_default_instance_._instance.get_mutable()->joints_ = const_cast< ::abb::egm::EgmJoints*>(
      ::abb::egm::EgmJoints::internal_default_instance());
  ::abb::egm::_EgmFeedBack_default_instance_._instance.get_mutable()->cartesian_ = const_cast< ::abb::egm::EgmPose*>(
      ::abb::egm::EgmPose::internal_default_instance());
  ::abb::egm::_EgmFeedBack_default_instance_._instance.get_mutable()->externaljoints_ = const_cast< ::abb::egm::EgmJoints*>(
      ::abb::egm::EgmJoints::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmFeedBack::kJointsFieldNumber;
const int EgmFeedBack::kCartesianFieldNumber;
const int EgmFeedBack::kExternalJointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmFeedBack::EgmFeedBack()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmFeedBack();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmFeedBack)
}
EgmFeedBack::EgmFeedBack(const EgmFeedBack& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_joints()) {
    joints_ = new ::abb::egm::EgmJoints(*from.joints_);
  } else {
    joints_ = NULL;
  }
  if (from.has_cartesian()) {
    cartesian_ = new ::abb::egm::EgmPose(*from.cartesian_);
  } else {
    cartesian_ = NULL;
  }
  if (from.has_externaljoints()) {
    externaljoints_ = new ::abb::egm::EgmJoints(*from.externaljoints_);
  } else {
    externaljoints_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmFeedBack)
}

void EgmFeedBack::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&joints_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&externaljoints_) -
      reinterpret_cast<char*>(&joints_)) + sizeof(externaljoints_));
}

EgmFeedBack::~EgmFeedBack() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmFeedBack)
  SharedDtor();
}

void EgmFeedBack::SharedDtor() {
  if (this != internal_default_instance()) delete joints_;
  if (this != internal_default_instance()) delete cartesian_;
  if (this != internal_default_instance()) delete externaljoints_;
}

void EgmFeedBack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmFeedBack::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmFeedBack& EgmFeedBack::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmFeedBack();
  return *internal_default_instance();
}

EgmFeedBack* EgmFeedBack::New(::google::protobuf::Arena* arena) const {
  EgmFeedBack* n = new EgmFeedBack;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmFeedBack::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmFeedBack)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(joints_ != NULL);
      joints_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(cartesian_ != NULL);
      cartesian_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(externaljoints_ != NULL);
      externaljoints_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmFeedBack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmFeedBack)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmJoints joints = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmPose cartesian = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_cartesian()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmJoints externalJoints = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_externaljoints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmFeedBack)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmFeedBack)
  return false;
#undef DO_
}

void EgmFeedBack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmFeedBack)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmJoints joints = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->joints_, output);
  }

  // optional .abb.egm.EgmPose cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->cartesian_, output);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->externaljoints_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmFeedBack)
}

::google::protobuf::uint8* EgmFeedBack::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmFeedBack)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmJoints joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->joints_, deterministic, target);
  }

  // optional .abb.egm.EgmPose cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->cartesian_, deterministic, target);
  }

  // optional .abb.egm.EgmJoints externalJoints = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->externaljoints_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmFeedBack)
  return target;
}

size_t EgmFeedBack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmFeedBack)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .abb.egm.EgmJoints joints = 1;
    if (has_joints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->joints_);
    }

    // optional .abb.egm.EgmPose cartesian = 2;
    if (has_cartesian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->cartesian_);
    }

    // optional .abb.egm.EgmJoints externalJoints = 3;
    if (has_externaljoints()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->externaljoints_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmFeedBack::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmFeedBack)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmFeedBack* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmFeedBack>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmFeedBack)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmFeedBack)
    MergeFrom(*source);
  }
}

void EgmFeedBack::MergeFrom(const EgmFeedBack& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmFeedBack)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_joints()->::abb::egm::EgmJoints::MergeFrom(from.joints());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_cartesian()->::abb::egm::EgmPose::MergeFrom(from.cartesian());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_externaljoints()->::abb::egm::EgmJoints::MergeFrom(from.externaljoints());
    }
  }
}

void EgmFeedBack::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmFeedBack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmFeedBack::CopyFrom(const EgmFeedBack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmFeedBack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmFeedBack::IsInitialized() const {
  if (has_cartesian()) {
    if (!this->cartesian_->IsInitialized()) return false;
  }
  return true;
}

void EgmFeedBack::Swap(EgmFeedBack* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmFeedBack::InternalSwap(EgmFeedBack* other) {
  using std::swap;
  swap(joints_, other->joints_);
  swap(cartesian_, other->cartesian_);
  swap(externaljoints_, other->externaljoints_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmFeedBack::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmMotorState::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmMotorState::kStateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmMotorState::EgmMotorState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmMotorState();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmMotorState)
}
EgmMotorState::EgmMotorState(const EgmMotorState& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  state_ = from.state_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmMotorState)
}

void EgmMotorState::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
}

EgmMotorState::~EgmMotorState() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmMotorState)
  SharedDtor();
}

void EgmMotorState::SharedDtor() {
}

void EgmMotorState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmMotorState::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmMotorState& EgmMotorState::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmMotorState();
  return *internal_default_instance();
}

EgmMotorState* EgmMotorState::New(::google::protobuf::Arena* arena) const {
  EgmMotorState* n = new EgmMotorState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmMotorState::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmMotorState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  state_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmMotorState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmMotorState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .abb.egm.EgmMotorState.MotorStateType state = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::EgmMotorState_MotorStateType_IsValid(value)) {
            set_state(static_cast< ::abb::egm::EgmMotorState_MotorStateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmMotorState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmMotorState)
  return false;
#undef DO_
}

void EgmMotorState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmMotorState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmMotorState)
}

::google::protobuf::uint8* EgmMotorState::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmMotorState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmMotorState)
  return target;
}

size_t EgmMotorState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmMotorState)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .abb.egm.EgmMotorState.MotorStateType state = 1;
  if (has_state()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmMotorState::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmMotorState)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmMotorState* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmMotorState>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmMotorState)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmMotorState)
    MergeFrom(*source);
  }
}

void EgmMotorState::MergeFrom(const EgmMotorState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmMotorState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_state()) {
    set_state(from.state());
  }
}

void EgmMotorState::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmMotorState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmMotorState::CopyFrom(const EgmMotorState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmMotorState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmMotorState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void EgmMotorState::Swap(EgmMotorState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmMotorState::InternalSwap(EgmMotorState* other) {
  using std::swap;
  swap(state_, other->state_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmMotorState::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmMCIState::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmMCIState::kStateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmMCIState::EgmMCIState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmMCIState();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmMCIState)
}
EgmMCIState::EgmMCIState(const EgmMCIState& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  state_ = from.state_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmMCIState)
}

void EgmMCIState::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
}

EgmMCIState::~EgmMCIState() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmMCIState)
  SharedDtor();
}

void EgmMCIState::SharedDtor() {
}

void EgmMCIState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmMCIState::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmMCIState& EgmMCIState::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmMCIState();
  return *internal_default_instance();
}

EgmMCIState* EgmMCIState::New(::google::protobuf::Arena* arena) const {
  EgmMCIState* n = new EgmMCIState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmMCIState::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmMCIState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  state_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmMCIState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmMCIState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::EgmMCIState_MCIStateType_IsValid(value)) {
            set_state(static_cast< ::abb::egm::EgmMCIState_MCIStateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmMCIState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmMCIState)
  return false;
#undef DO_
}

void EgmMCIState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmMCIState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmMCIState)
}

::google::protobuf::uint8* EgmMCIState::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmMCIState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmMCIState)
  return target;
}

size_t EgmMCIState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmMCIState)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .abb.egm.EgmMCIState.MCIStateType state = 1 [default = MCI_UNDEFINED];
  if (has_state()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmMCIState::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmMCIState)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmMCIState* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmMCIState>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmMCIState)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmMCIState)
    MergeFrom(*source);
  }
}

void EgmMCIState::MergeFrom(const EgmMCIState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmMCIState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_state()) {
    set_state(from.state());
  }
}

void EgmMCIState::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmMCIState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmMCIState::CopyFrom(const EgmMCIState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmMCIState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmMCIState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void EgmMCIState::Swap(EgmMCIState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmMCIState::InternalSwap(EgmMCIState* other) {
  using std::swap;
  swap(state_, other->state_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmMCIState::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmRapidCtrlExecState::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmRapidCtrlExecState::kStateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmRapidCtrlExecState::EgmRapidCtrlExecState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmRapidCtrlExecState();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmRapidCtrlExecState)
}
EgmRapidCtrlExecState::EgmRapidCtrlExecState(const EgmRapidCtrlExecState& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  state_ = from.state_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmRapidCtrlExecState)
}

void EgmRapidCtrlExecState::SharedCtor() {
  _cached_size_ = 0;
  state_ = 0;
}

EgmRapidCtrlExecState::~EgmRapidCtrlExecState() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmRapidCtrlExecState)
  SharedDtor();
}

void EgmRapidCtrlExecState::SharedDtor() {
}

void EgmRapidCtrlExecState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmRapidCtrlExecState::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmRapidCtrlExecState& EgmRapidCtrlExecState::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmRapidCtrlExecState();
  return *internal_default_instance();
}

EgmRapidCtrlExecState* EgmRapidCtrlExecState::New(::google::protobuf::Arena* arena) const {
  EgmRapidCtrlExecState* n = new EgmRapidCtrlExecState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmRapidCtrlExecState::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmRapidCtrlExecState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  state_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmRapidCtrlExecState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmRapidCtrlExecState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType_IsValid(value)) {
            set_state(static_cast< ::abb::egm::EgmRapidCtrlExecState_RapidCtrlExecStateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmRapidCtrlExecState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmRapidCtrlExecState)
  return false;
#undef DO_
}

void EgmRapidCtrlExecState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmRapidCtrlExecState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmRapidCtrlExecState)
}

::google::protobuf::uint8* EgmRapidCtrlExecState::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmRapidCtrlExecState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmRapidCtrlExecState)
  return target;
}

size_t EgmRapidCtrlExecState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmRapidCtrlExecState)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .abb.egm.EgmRapidCtrlExecState.RapidCtrlExecStateType state = 1 [default = RAPID_UNDEFINED];
  if (has_state()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmRapidCtrlExecState::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmRapidCtrlExecState)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmRapidCtrlExecState* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmRapidCtrlExecState>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmRapidCtrlExecState)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmRapidCtrlExecState)
    MergeFrom(*source);
  }
}

void EgmRapidCtrlExecState::MergeFrom(const EgmRapidCtrlExecState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmRapidCtrlExecState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_state()) {
    set_state(from.state());
  }
}

void EgmRapidCtrlExecState::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmRapidCtrlExecState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmRapidCtrlExecState::CopyFrom(const EgmRapidCtrlExecState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmRapidCtrlExecState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmRapidCtrlExecState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void EgmRapidCtrlExecState::Swap(EgmRapidCtrlExecState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmRapidCtrlExecState::InternalSwap(EgmRapidCtrlExecState* other) {
  using std::swap;
  swap(state_, other->state_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmRapidCtrlExecState::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmTestSignals::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmTestSignals::kSignalsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmTestSignals::EgmTestSignals()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmTestSignals();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmTestSignals)
}
EgmTestSignals::EgmTestSignals(const EgmTestSignals& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      signals_(from.signals_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmTestSignals)
}

void EgmTestSignals::SharedCtor() {
  _cached_size_ = 0;
}

EgmTestSignals::~EgmTestSignals() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmTestSignals)
  SharedDtor();
}

void EgmTestSignals::SharedDtor() {
}

void EgmTestSignals::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmTestSignals::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmTestSignals& EgmTestSignals::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmTestSignals();
  return *internal_default_instance();
}

EgmTestSignals* EgmTestSignals::New(::google::protobuf::Arena* arena) const {
  EgmTestSignals* n = new EgmTestSignals;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmTestSignals::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmTestSignals)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  signals_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmTestSignals::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmTestSignals)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double signals = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(9u /* 9 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9u, input, this->mutable_signals())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_signals())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmTestSignals)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmTestSignals)
  return false;
#undef DO_
}

void EgmTestSignals::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmTestSignals)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double signals = 1;
  for (int i = 0, n = this->signals_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->signals(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmTestSignals)
}

::google::protobuf::uint8* EgmTestSignals::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmTestSignals)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double signals = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(1, this->signals_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmTestSignals)
  return target;
}

size_t EgmTestSignals::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmTestSignals)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated double signals = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->signals_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->signals_size());
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmTestSignals::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmTestSignals)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmTestSignals* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmTestSignals>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmTestSignals)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmTestSignals)
    MergeFrom(*source);
  }
}

void EgmTestSignals::MergeFrom(const EgmTestSignals& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmTestSignals)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  signals_.MergeFrom(from.signals_);
}

void EgmTestSignals::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmTestSignals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmTestSignals::CopyFrom(const EgmTestSignals& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmTestSignals)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmTestSignals::IsInitialized() const {
  return true;
}

void EgmTestSignals::Swap(EgmTestSignals* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmTestSignals::InternalSwap(EgmTestSignals* other) {
  using std::swap;
  signals_.InternalSwap(&other->signals_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmTestSignals::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmRobot::InitAsDefaultInstance() {
  ::abb::egm::_EgmRobot_default_instance_._instance.get_mutable()->header_ = const_cast< ::abb::egm::EgmHeader*>(
      ::abb::egm::EgmHeader::internal_default_instance());
  ::abb::egm::_EgmRobot_default_instance_._instance.get_mutable()->feedback_ = const_cast< ::abb::egm::EgmFeedBack*>(
      ::abb::egm::EgmFeedBack::internal_default_instance());
  ::abb::egm::_EgmRobot_default_instance_._instance.get_mutable()->planned_ = const_cast< ::abb::egm::EgmPlanned*>(
      ::abb::egm::EgmPlanned::internal_default_instance());
  ::abb::egm::_EgmRobot_default_instance_._instance.get_mutable()->motorstate_ = const_cast< ::abb::egm::EgmMotorState*>(
      ::abb::egm::EgmMotorState::internal_default_instance());
  ::abb::egm::_EgmRobot_default_instance_._instance.get_mutable()->mcistate_ = const_cast< ::abb::egm::EgmMCIState*>(
      ::abb::egm::EgmMCIState::internal_default_instance());
  ::abb::egm::_EgmRobot_default_instance_._instance.get_mutable()->testsignals_ = const_cast< ::abb::egm::EgmTestSignals*>(
      ::abb::egm::EgmTestSignals::internal_default_instance());
  ::abb::egm::_EgmRobot_default_instance_._instance.get_mutable()->rapidexecstate_ = const_cast< ::abb::egm::EgmRapidCtrlExecState*>(
      ::abb::egm::EgmRapidCtrlExecState::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmRobot::kHeaderFieldNumber;
const int EgmRobot::kFeedBackFieldNumber;
const int EgmRobot::kPlannedFieldNumber;
const int EgmRobot::kMotorStateFieldNumber;
const int EgmRobot::kMciStateFieldNumber;
const int EgmRobot::kMciConvergenceMetFieldNumber;
const int EgmRobot::kTestSignalsFieldNumber;
const int EgmRobot::kRapidExecStateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmRobot::EgmRobot()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmRobot();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmRobot)
}
EgmRobot::EgmRobot(const EgmRobot& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::abb::egm::EgmHeader(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_feedback()) {
    feedback_ = new ::abb::egm::EgmFeedBack(*from.feedback_);
  } else {
    feedback_ = NULL;
  }
  if (from.has_planned()) {
    planned_ = new ::abb::egm::EgmPlanned(*from.planned_);
  } else {
    planned_ = NULL;
  }
  if (from.has_motorstate()) {
    motorstate_ = new ::abb::egm::EgmMotorState(*from.motorstate_);
  } else {
    motorstate_ = NULL;
  }
  if (from.has_mcistate()) {
    mcistate_ = new ::abb::egm::EgmMCIState(*from.mcistate_);
  } else {
    mcistate_ = NULL;
  }
  if (from.has_testsignals()) {
    testsignals_ = new ::abb::egm::EgmTestSignals(*from.testsignals_);
  } else {
    testsignals_ = NULL;
  }
  if (from.has_rapidexecstate()) {
    rapidexecstate_ = new ::abb::egm::EgmRapidCtrlExecState(*from.rapidexecstate_);
  } else {
    rapidexecstate_ = NULL;
  }
  mciconvergencemet_ = from.mciconvergencemet_;
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmRobot)
}

void EgmRobot::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mciconvergencemet_) -
      reinterpret_cast<char*>(&header_)) + sizeof(mciconvergencemet_));
}

EgmRobot::~EgmRobot() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmRobot)
  SharedDtor();
}

void EgmRobot::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete feedback_;
  if (this != internal_default_instance()) delete planned_;
  if (this != internal_default_instance()) delete motorstate_;
  if (this != internal_default_instance()) delete mcistate_;
  if (this != internal_default_instance()) delete testsignals_;
  if (this != internal_default_instance()) delete rapidexecstate_;
}

void EgmRobot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmRobot::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmRobot& EgmRobot::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmRobot();
  return *internal_default_instance();
}

EgmRobot* EgmRobot::New(::google::protobuf::Arena* arena) const {
  EgmRobot* n = new EgmRobot;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmRobot::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmRobot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 127u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != NULL);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(feedback_ != NULL);
      feedback_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(planned_ != NULL);
      planned_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(motorstate_ != NULL);
      motorstate_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(mcistate_ != NULL);
      mcistate_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(testsignals_ != NULL);
      testsignals_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(rapidexecstate_ != NULL);
      rapidexecstate_->Clear();
    }
  }
  mciconvergencemet_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmRobot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmRobot)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmHeader header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmFeedBack feedBack = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_feedback()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmPlanned planned = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_planned()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmMotorState motorState = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_motorstate()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmMCIState mciState = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_mcistate()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool mciConvergenceMet = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_mciconvergencemet();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mciconvergencemet_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmTestSignals testSignals = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_testsignals()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_rapidexecstate()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmRobot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmRobot)
  return false;
#undef DO_
}

void EgmRobot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmRobot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .abb.egm.EgmFeedBack feedBack = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->feedback_, output);
  }

  // optional .abb.egm.EgmPlanned planned = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->planned_, output);
  }

  // optional .abb.egm.EgmMotorState motorState = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->motorstate_, output);
  }

  // optional .abb.egm.EgmMCIState mciState = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->mcistate_, output);
  }

  // optional bool mciConvergenceMet = 6;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->mciconvergencemet(), output);
  }

  // optional .abb.egm.EgmTestSignals testSignals = 7;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->testsignals_, output);
  }

  // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->rapidexecstate_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmRobot)
}

::google::protobuf::uint8* EgmRobot::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmRobot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->header_, deterministic, target);
  }

  // optional .abb.egm.EgmFeedBack feedBack = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->feedback_, deterministic, target);
  }

  // optional .abb.egm.EgmPlanned planned = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->planned_, deterministic, target);
  }

  // optional .abb.egm.EgmMotorState motorState = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, *this->motorstate_, deterministic, target);
  }

  // optional .abb.egm.EgmMCIState mciState = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, *this->mcistate_, deterministic, target);
  }

  // optional bool mciConvergenceMet = 6;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->mciconvergencemet(), target);
  }

  // optional .abb.egm.EgmTestSignals testSignals = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, *this->testsignals_, deterministic, target);
  }

  // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, *this->rapidexecstate_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmRobot)
  return target;
}

size_t EgmRobot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmRobot)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional .abb.egm.EgmHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->header_);
    }

    // optional .abb.egm.EgmFeedBack feedBack = 2;
    if (has_feedback()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->feedback_);
    }

    // optional .abb.egm.EgmPlanned planned = 3;
    if (has_planned()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->planned_);
    }

    // optional .abb.egm.EgmMotorState motorState = 4;
    if (has_motorstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->motorstate_);
    }

    // optional .abb.egm.EgmMCIState mciState = 5;
    if (has_mcistate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->mcistate_);
    }

    // optional .abb.egm.EgmTestSignals testSignals = 7;
    if (has_testsignals()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->testsignals_);
    }

    // optional .abb.egm.EgmRapidCtrlExecState rapidExecState = 8;
    if (has_rapidexecstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->rapidexecstate_);
    }

    // optional bool mciConvergenceMet = 6;
    if (has_mciconvergencemet()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmRobot::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmRobot)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmRobot* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmRobot>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmRobot)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmRobot)
    MergeFrom(*source);
  }
}

void EgmRobot::MergeFrom(const EgmRobot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmRobot)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_header()->::abb::egm::EgmHeader::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_feedback()->::abb::egm::EgmFeedBack::MergeFrom(from.feedback());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_planned()->::abb::egm::EgmPlanned::MergeFrom(from.planned());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_motorstate()->::abb::egm::EgmMotorState::MergeFrom(from.motorstate());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_mcistate()->::abb::egm::EgmMCIState::MergeFrom(from.mcistate());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_testsignals()->::abb::egm::EgmTestSignals::MergeFrom(from.testsignals());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_rapidexecstate()->::abb::egm::EgmRapidCtrlExecState::MergeFrom(from.rapidexecstate());
    }
    if (cached_has_bits & 0x00000080u) {
      mciconvergencemet_ = from.mciconvergencemet_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EgmRobot::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmRobot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmRobot::CopyFrom(const EgmRobot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmRobot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmRobot::IsInitialized() const {
  if (has_feedback()) {
    if (!this->feedback_->IsInitialized()) return false;
  }
  if (has_planned()) {
    if (!this->planned_->IsInitialized()) return false;
  }
  if (has_motorstate()) {
    if (!this->motorstate_->IsInitialized()) return false;
  }
  if (has_mcistate()) {
    if (!this->mcistate_->IsInitialized()) return false;
  }
  if (has_rapidexecstate()) {
    if (!this->rapidexecstate_->IsInitialized()) return false;
  }
  return true;
}

void EgmRobot::Swap(EgmRobot* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmRobot::InternalSwap(EgmRobot* other) {
  using std::swap;
  swap(header_, other->header_);
  swap(feedback_, other->feedback_);
  swap(planned_, other->planned_);
  swap(motorstate_, other->motorstate_);
  swap(mcistate_, other->mcistate_);
  swap(testsignals_, other->testsignals_);
  swap(rapidexecstate_, other->rapidexecstate_);
  swap(mciconvergencemet_, other->mciconvergencemet_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmRobot::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmSensor::InitAsDefaultInstance() {
  ::abb::egm::_EgmSensor_default_instance_._instance.get_mutable()->header_ = const_cast< ::abb::egm::EgmHeader*>(
      ::abb::egm::EgmHeader::internal_default_instance());
  ::abb::egm::_EgmSensor_default_instance_._instance.get_mutable()->planned_ = const_cast< ::abb::egm::EgmPlanned*>(
      ::abb::egm::EgmPlanned::internal_default_instance());
  ::abb::egm::_EgmSensor_default_instance_._instance.get_mutable()->speedref_ = const_cast< ::abb::egm::EgmSpeedRef*>(
      ::abb::egm::EgmSpeedRef::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmSensor::kHeaderFieldNumber;
const int EgmSensor::kPlannedFieldNumber;
const int EgmSensor::kSpeedRefFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmSensor::EgmSensor()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmSensor();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmSensor)
}
EgmSensor::EgmSensor(const EgmSensor& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::abb::egm::EgmHeader(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_planned()) {
    planned_ = new ::abb::egm::EgmPlanned(*from.planned_);
  } else {
    planned_ = NULL;
  }
  if (from.has_speedref()) {
    speedref_ = new ::abb::egm::EgmSpeedRef(*from.speedref_);
  } else {
    speedref_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmSensor)
}

void EgmSensor::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&speedref_) -
      reinterpret_cast<char*>(&header_)) + sizeof(speedref_));
}

EgmSensor::~EgmSensor() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmSensor)
  SharedDtor();
}

void EgmSensor::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete planned_;
  if (this != internal_default_instance()) delete speedref_;
}

void EgmSensor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmSensor::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmSensor& EgmSensor::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmSensor();
  return *internal_default_instance();
}

EgmSensor* EgmSensor::New(::google::protobuf::Arena* arena) const {
  EgmSensor* n = new EgmSensor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmSensor::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmSensor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != NULL);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(planned_ != NULL);
      planned_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(speedref_ != NULL);
      speedref_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmSensor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmSensor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmHeader header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmPlanned planned = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_planned()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmSpeedRef speedRef = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_speedref()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmSensor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmSensor)
  return false;
#undef DO_
}

void EgmSensor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmSensor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .abb.egm.EgmPlanned planned = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->planned_, output);
  }

  // optional .abb.egm.EgmSpeedRef speedRef = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->speedref_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmSensor)
}

::google::protobuf::uint8* EgmSensor::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmSensor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->header_, deterministic, target);
  }

  // optional .abb.egm.EgmPlanned planned = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->planned_, deterministic, target);
  }

  // optional .abb.egm.EgmSpeedRef speedRef = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->speedref_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmSensor)
  return target;
}

size_t EgmSensor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmSensor)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .abb.egm.EgmHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->header_);
    }

    // optional .abb.egm.EgmPlanned planned = 2;
    if (has_planned()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->planned_);
    }

    // optional .abb.egm.EgmSpeedRef speedRef = 3;
    if (has_speedref()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->speedref_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmSensor::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmSensor)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmSensor* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmSensor>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmSensor)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmSensor)
    MergeFrom(*source);
  }
}

void EgmSensor::MergeFrom(const EgmSensor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmSensor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_header()->::abb::egm::EgmHeader::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_planned()->::abb::egm::EgmPlanned::MergeFrom(from.planned());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_speedref()->::abb::egm::EgmSpeedRef::MergeFrom(from.speedref());
    }
  }
}

void EgmSensor::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmSensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmSensor::CopyFrom(const EgmSensor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmSensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmSensor::IsInitialized() const {
  if (has_planned()) {
    if (!this->planned_->IsInitialized()) return false;
  }
  return true;
}

void EgmSensor::Swap(EgmSensor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmSensor::InternalSwap(EgmSensor* other) {
  using std::swap;
  swap(header_, other->header_);
  swap(planned_, other->planned_);
  swap(speedref_, other->speedref_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmSensor::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void EgmSensorPathCorr::InitAsDefaultInstance() {
  ::abb::egm::_EgmSensorPathCorr_default_instance_._instance.get_mutable()->header_ = const_cast< ::abb::egm::EgmHeader*>(
      ::abb::egm::EgmHeader::internal_default_instance());
  ::abb::egm::_EgmSensorPathCorr_default_instance_._instance.get_mutable()->pathcorr_ = const_cast< ::abb::egm::EgmPathCorr*>(
      ::abb::egm::EgmPathCorr::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EgmSensorPathCorr::kHeaderFieldNumber;
const int EgmSensorPathCorr::kPathCorrFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EgmSensorPathCorr::EgmSensorPathCorr()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_egm_2eproto::InitDefaultsEgmSensorPathCorr();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.EgmSensorPathCorr)
}
EgmSensorPathCorr::EgmSensorPathCorr(const EgmSensorPathCorr& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::abb::egm::EgmHeader(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_pathcorr()) {
    pathcorr_ = new ::abb::egm::EgmPathCorr(*from.pathcorr_);
  } else {
    pathcorr_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.EgmSensorPathCorr)
}

void EgmSensorPathCorr::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pathcorr_) -
      reinterpret_cast<char*>(&header_)) + sizeof(pathcorr_));
}

EgmSensorPathCorr::~EgmSensorPathCorr() {
  // @@protoc_insertion_point(destructor:abb.egm.EgmSensorPathCorr)
  SharedDtor();
}

void EgmSensorPathCorr::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete pathcorr_;
}

void EgmSensorPathCorr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EgmSensorPathCorr::descriptor() {
  ::protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EgmSensorPathCorr& EgmSensorPathCorr::default_instance() {
  ::protobuf_egm_2eproto::InitDefaultsEgmSensorPathCorr();
  return *internal_default_instance();
}

EgmSensorPathCorr* EgmSensorPathCorr::New(::google::protobuf::Arena* arena) const {
  EgmSensorPathCorr* n = new EgmSensorPathCorr;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EgmSensorPathCorr::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.EgmSensorPathCorr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != NULL);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(pathcorr_ != NULL);
      pathcorr_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EgmSensorPathCorr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.EgmSensorPathCorr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.EgmHeader header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.EgmPathCorr pathCorr = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_pathcorr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.EgmSensorPathCorr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.EgmSensorPathCorr)
  return false;
#undef DO_
}

void EgmSensorPathCorr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.EgmSensorPathCorr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .abb.egm.EgmPathCorr pathCorr = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pathcorr_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.EgmSensorPathCorr)
}

::google::protobuf::uint8* EgmSensorPathCorr::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.EgmSensorPathCorr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.EgmHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->header_, deterministic, target);
  }

  // optional .abb.egm.EgmPathCorr pathCorr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->pathcorr_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.EgmSensorPathCorr)
  return target;
}

size_t EgmSensorPathCorr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.EgmSensorPathCorr)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .abb.egm.EgmHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->header_);
    }

    // optional .abb.egm.EgmPathCorr pathCorr = 2;
    if (has_pathcorr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->pathcorr_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EgmSensorPathCorr::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.EgmSensorPathCorr)
  GOOGLE_DCHECK_NE(&from, this);
  const EgmSensorPathCorr* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EgmSensorPathCorr>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.EgmSensorPathCorr)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.EgmSensorPathCorr)
    MergeFrom(*source);
  }
}

void EgmSensorPathCorr::MergeFrom(const EgmSensorPathCorr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.EgmSensorPathCorr)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_header()->::abb::egm::EgmHeader::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_pathcorr()->::abb::egm::EgmPathCorr::MergeFrom(from.pathcorr());
    }
  }
}

void EgmSensorPathCorr::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.EgmSensorPathCorr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EgmSensorPathCorr::CopyFrom(const EgmSensorPathCorr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.EgmSensorPathCorr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EgmSensorPathCorr::IsInitialized() const {
  if (has_pathcorr()) {
    if (!this->pathcorr_->IsInitialized()) return false;
  }
  return true;
}

void EgmSensorPathCorr::Swap(EgmSensorPathCorr* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EgmSensorPathCorr::InternalSwap(EgmSensorPathCorr* other) {
  using std::swap;
  swap(header_, other->header_);
  swap(pathcorr_, other->pathcorr_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EgmSensorPathCorr::GetMetadata() const {
  protobuf_egm_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_egm_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace egm
}  // namespace abb

// @@protoc_insertion_point(global_scope)
