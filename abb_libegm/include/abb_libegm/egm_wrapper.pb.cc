// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: egm_wrapper.proto

#include "egm_wrapper.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Cartesian_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Euler_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Header_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Joints_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Quaternion_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Status_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_External_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_JointSpace_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_CartesianSpace_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_CartesianVelocity_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_Feedback_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_Planned_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_Robot_egm_5fwrapper_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_egm_5fwrapper_2eproto ::google::protobuf::internal::SCCInfo<3> scc_info_CartesianPose_egm_5fwrapper_2eproto;
namespace abb {
namespace egm {
namespace wrapper {
class HeaderDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Header> _instance;
} _Header_default_instance_;
class StatusDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Status> _instance;
} _Status_default_instance_;
class JointsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Joints> _instance;
} _Joints_default_instance_;
class JointSpaceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<JointSpace> _instance;
} _JointSpace_default_instance_;
class CartesianDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Cartesian> _instance;
} _Cartesian_default_instance_;
class EulerDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Euler> _instance;
} _Euler_default_instance_;
class QuaternionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Quaternion> _instance;
} _Quaternion_default_instance_;
class CartesianPoseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CartesianPose> _instance;
} _CartesianPose_default_instance_;
class CartesianVelocityDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CartesianVelocity> _instance;
} _CartesianVelocity_default_instance_;
class CartesianSpaceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CartesianSpace> _instance;
} _CartesianSpace_default_instance_;
class RobotDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Robot> _instance;
} _Robot_default_instance_;
class ExternalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<External> _instance;
} _External_default_instance_;
class FeedbackDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Feedback> _instance;
} _Feedback_default_instance_;
class PlannedDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Planned> _instance;
} _Planned_default_instance_;
class InputDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Input> _instance;
} _Input_default_instance_;
class OutputDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Output> _instance;
} _Output_default_instance_;
}  // namespace wrapper
}  // namespace egm
}  // namespace abb
static void InitDefaultsHeader_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Header_default_instance_;
    new (ptr) ::abb::egm::wrapper::Header();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Header::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Header_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsHeader_egm_5fwrapper_2eproto}, {}};

static void InitDefaultsStatus_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Status_default_instance_;
    new (ptr) ::abb::egm::wrapper::Status();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Status::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Status_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsStatus_egm_5fwrapper_2eproto}, {}};

static void InitDefaultsJoints_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Joints_default_instance_;
    new (ptr) ::abb::egm::wrapper::Joints();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Joints::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Joints_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsJoints_egm_5fwrapper_2eproto}, {}};

static void InitDefaultsJointSpace_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_JointSpace_default_instance_;
    new (ptr) ::abb::egm::wrapper::JointSpace();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::JointSpace::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_JointSpace_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsJointSpace_egm_5fwrapper_2eproto}, {
      &scc_info_Joints_egm_5fwrapper_2eproto.base,}};

static void InitDefaultsCartesian_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Cartesian_default_instance_;
    new (ptr) ::abb::egm::wrapper::Cartesian();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Cartesian::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Cartesian_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsCartesian_egm_5fwrapper_2eproto}, {}};

static void InitDefaultsEuler_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Euler_default_instance_;
    new (ptr) ::abb::egm::wrapper::Euler();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Euler::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Euler_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEuler_egm_5fwrapper_2eproto}, {}};

static void InitDefaultsQuaternion_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Quaternion_default_instance_;
    new (ptr) ::abb::egm::wrapper::Quaternion();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Quaternion::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Quaternion_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsQuaternion_egm_5fwrapper_2eproto}, {}};

static void InitDefaultsCartesianPose_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_CartesianPose_default_instance_;
    new (ptr) ::abb::egm::wrapper::CartesianPose();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::CartesianPose::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<3> scc_info_CartesianPose_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsCartesianPose_egm_5fwrapper_2eproto}, {
      &scc_info_Cartesian_egm_5fwrapper_2eproto.base,
      &scc_info_Euler_egm_5fwrapper_2eproto.base,
      &scc_info_Quaternion_egm_5fwrapper_2eproto.base,}};

static void InitDefaultsCartesianVelocity_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_CartesianVelocity_default_instance_;
    new (ptr) ::abb::egm::wrapper::CartesianVelocity();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::CartesianVelocity::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CartesianVelocity_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCartesianVelocity_egm_5fwrapper_2eproto}, {
      &scc_info_Cartesian_egm_5fwrapper_2eproto.base,
      &scc_info_Euler_egm_5fwrapper_2eproto.base,}};

static void InitDefaultsCartesianSpace_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_CartesianSpace_default_instance_;
    new (ptr) ::abb::egm::wrapper::CartesianSpace();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::CartesianSpace::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_CartesianSpace_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsCartesianSpace_egm_5fwrapper_2eproto}, {
      &scc_info_CartesianPose_egm_5fwrapper_2eproto.base,
      &scc_info_CartesianVelocity_egm_5fwrapper_2eproto.base,}};

static void InitDefaultsRobot_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Robot_default_instance_;
    new (ptr) ::abb::egm::wrapper::Robot();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Robot::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Robot_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsRobot_egm_5fwrapper_2eproto}, {
      &scc_info_JointSpace_egm_5fwrapper_2eproto.base,
      &scc_info_CartesianSpace_egm_5fwrapper_2eproto.base,}};

static void InitDefaultsExternal_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_External_default_instance_;
    new (ptr) ::abb::egm::wrapper::External();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::External::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_External_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsExternal_egm_5fwrapper_2eproto}, {
      &scc_info_JointSpace_egm_5fwrapper_2eproto.base,}};

static void InitDefaultsFeedback_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Feedback_default_instance_;
    new (ptr) ::abb::egm::wrapper::Feedback();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Feedback::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Feedback_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsFeedback_egm_5fwrapper_2eproto}, {
      &scc_info_Robot_egm_5fwrapper_2eproto.base,
      &scc_info_External_egm_5fwrapper_2eproto.base,}};

static void InitDefaultsPlanned_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Planned_default_instance_;
    new (ptr) ::abb::egm::wrapper::Planned();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Planned::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Planned_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsPlanned_egm_5fwrapper_2eproto}, {
      &scc_info_Robot_egm_5fwrapper_2eproto.base,
      &scc_info_External_egm_5fwrapper_2eproto.base,}};

static void InitDefaultsInput_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Input_default_instance_;
    new (ptr) ::abb::egm::wrapper::Input();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Input::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<4> scc_info_Input_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsInput_egm_5fwrapper_2eproto}, {
      &scc_info_Header_egm_5fwrapper_2eproto.base,
      &scc_info_Feedback_egm_5fwrapper_2eproto.base,
      &scc_info_Planned_egm_5fwrapper_2eproto.base,
      &scc_info_Status_egm_5fwrapper_2eproto.base,}};

static void InitDefaultsOutput_egm_5fwrapper_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::abb::egm::wrapper::_Output_default_instance_;
    new (ptr) ::abb::egm::wrapper::Output();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::abb::egm::wrapper::Output::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Output_egm_5fwrapper_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsOutput_egm_5fwrapper_2eproto}, {
      &scc_info_Robot_egm_5fwrapper_2eproto.base,
      &scc_info_External_egm_5fwrapper_2eproto.base,}};

void InitDefaults_egm_5fwrapper_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_Header_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Status_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Joints_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_JointSpace_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Cartesian_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Euler_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Quaternion_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CartesianPose_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CartesianVelocity_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_CartesianSpace_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Robot_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_External_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Feedback_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Planned_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Input_egm_5fwrapper_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Output_egm_5fwrapper_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_egm_5fwrapper_2eproto[16];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_egm_5fwrapper_2eproto[4];
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_egm_5fwrapper_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_egm_5fwrapper_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Header, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Header, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Header, sequance_number_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Header, time_stamp_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Header, message_type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Status, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Status, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Status, egm_convergence_met_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Status, egm_state_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Status, motor_state_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Status, rapid_execution_state_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Joints, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Joints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Joints, values_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::JointSpace, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::JointSpace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::JointSpace, position_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::JointSpace, velocity_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, x_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, y_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Cartesian, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Euler, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Euler, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Euler, x_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Euler, y_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Euler, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, u0_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, u1_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, u2_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Quaternion, u3_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, position_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, euler_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianPose, quaternion_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianVelocity, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianVelocity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianVelocity, linear_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianVelocity, angular_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianSpace, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianSpace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianSpace, pose_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::CartesianSpace, velocity_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Robot, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Robot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Robot, joints_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Robot, cartesian_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::External, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::External, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::External, joints_),
  0,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Feedback, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Feedback, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Feedback, robot_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Feedback, external_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Planned, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Planned, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Planned, robot_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Planned, external_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Input, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Input, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Input, header_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Input, feedback_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Input, planned_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Input, status_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Output, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Output, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Output, robot_),
  PROTOBUF_FIELD_OFFSET(::abb::egm::wrapper::Output, external_),
  0,
  1,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::abb::egm::wrapper::Header)},
  { 11, 20, sizeof(::abb::egm::wrapper::Status)},
  { 24, 30, sizeof(::abb::egm::wrapper::Joints)},
  { 31, 38, sizeof(::abb::egm::wrapper::JointSpace)},
  { 40, 48, sizeof(::abb::egm::wrapper::Cartesian)},
  { 51, 59, sizeof(::abb::egm::wrapper::Euler)},
  { 62, 71, sizeof(::abb::egm::wrapper::Quaternion)},
  { 75, 83, sizeof(::abb::egm::wrapper::CartesianPose)},
  { 86, 93, sizeof(::abb::egm::wrapper::CartesianVelocity)},
  { 95, 102, sizeof(::abb::egm::wrapper::CartesianSpace)},
  { 104, 111, sizeof(::abb::egm::wrapper::Robot)},
  { 113, 119, sizeof(::abb::egm::wrapper::External)},
  { 120, 127, sizeof(::abb::egm::wrapper::Feedback)},
  { 129, 136, sizeof(::abb::egm::wrapper::Planned)},
  { 138, 147, sizeof(::abb::egm::wrapper::Input)},
  { 151, 158, sizeof(::abb::egm::wrapper::Output)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Header_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Status_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Joints_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_JointSpace_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Cartesian_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Euler_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Quaternion_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_CartesianPose_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_CartesianVelocity_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_CartesianSpace_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Robot_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_External_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Feedback_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Planned_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Input_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::abb::egm::wrapper::_Output_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_egm_5fwrapper_2eproto = {
  {}, AddDescriptors_egm_5fwrapper_2eproto, "egm_wrapper.proto", schemas,
  file_default_instances, TableStruct_egm_5fwrapper_2eproto::offsets,
  file_level_metadata_egm_5fwrapper_2eproto, 16, file_level_enum_descriptors_egm_5fwrapper_2eproto, file_level_service_descriptors_egm_5fwrapper_2eproto,
};

::google::protobuf::internal::DescriptorTable descriptor_table_egm_5fwrapper_2eproto = {
  false, InitDefaults_egm_5fwrapper_2eproto, 
  "\n\021egm_wrapper.proto\022\017abb.egm.wrapper\"\243\001\n"
  "\006Header\022\027\n\017sequance_number\030\001 \001(\r\022\022\n\ntime"
  "_stamp\030\002 \001(\r\022D\n\014message_type\030\003 \001(\0162#.abb"
  ".egm.wrapper.Header.MessageType:\tUNDEFIN"
  "ED\"&\n\013MessageType\022\r\n\tUNDEFINED\020\000\022\010\n\004DATA"
  "\020\001\"\366\003\n\006Status\022\033\n\023egm_convergence_met\030\001 \001"
  "(\010\022B\n\tegm_state\030\002 \001(\0162 .abb.egm.wrapper."
  "Status.EGMState:\rEGM_UNDEFINED\022I\n\013motor_"
  "state\030\003 \001(\0162\".abb.egm.wrapper.Status.Mot"
  "orState:\020MOTORS_UNDEFINED\022[\n\025rapid_execu"
  "tion_state\030\004 \001(\0162+.abb.egm.wrapper.Statu"
  "s.RAPIDExecutionState:\017RAPID_UNDEFINED\"N"
  "\n\010EGMState\022\021\n\rEGM_UNDEFINED\020\000\022\r\n\tEGM_ERR"
  "OR\020\001\022\017\n\013EGM_STOPPED\020\002\022\017\n\013EGM_RUNNING\020\003\"A"
  "\n\nMotorState\022\024\n\020MOTORS_UNDEFINED\020\000\022\r\n\tMO"
  "TORS_ON\020\001\022\016\n\nMOTORS_OFF\020\002\"P\n\023RAPIDExecut"
  "ionState\022\023\n\017RAPID_UNDEFINED\020\000\022\021\n\rRAPID_S"
  "TOPPED\020\001\022\021\n\rRAPID_RUNNING\020\002\"\030\n\006Joints\022\016\n"
  "\006values\030\001 \003(\001\"b\n\nJointSpace\022)\n\010position\030"
  "\001 \001(\0132\027.abb.egm.wrapper.Joints\022)\n\010veloci"
  "ty\030\002 \001(\0132\027.abb.egm.wrapper.Joints\",\n\tCar"
  "tesian\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001(\001\""
  "(\n\005Euler\022\t\n\001x\030\001 \001(\001\022\t\n\001y\030\002 \001(\001\022\t\n\001z\030\003 \001("
  "\001\"<\n\nQuaternion\022\n\n\002u0\030\001 \001(\001\022\n\n\002u1\030\002 \001(\001\022"
  "\n\n\002u2\030\003 \001(\001\022\n\n\002u3\030\004 \001(\001\"\225\001\n\rCartesianPos"
  "e\022,\n\010position\030\001 \001(\0132\032.abb.egm.wrapper.Ca"
  "rtesian\022%\n\005euler\030\002 \001(\0132\026.abb.egm.wrapper"
  ".Euler\022/\n\nquaternion\030\003 \001(\0132\033.abb.egm.wra"
  "pper.Quaternion\"h\n\021CartesianVelocity\022*\n\006"
  "linear\030\001 \001(\0132\032.abb.egm.wrapper.Cartesian"
  "\022\'\n\007angular\030\002 \001(\0132\026.abb.egm.wrapper.Eule"
  "r\"t\n\016CartesianSpace\022,\n\004pose\030\001 \001(\0132\036.abb."
  "egm.wrapper.CartesianPose\0224\n\010velocity\030\002 "
  "\001(\0132\".abb.egm.wrapper.CartesianVelocity\""
  "h\n\005Robot\022+\n\006joints\030\001 \001(\0132\033.abb.egm.wrapp"
  "er.JointSpace\0222\n\tcartesian\030\002 \001(\0132\037.abb.e"
  "gm.wrapper.CartesianSpace\"7\n\010External\022+\n"
  "\006joints\030\001 \001(\0132\033.abb.egm.wrapper.JointSpa"
  "ce\"^\n\010Feedback\022%\n\005robot\030\001 \001(\0132\026.abb.egm."
  "wrapper.Robot\022+\n\010external\030\002 \001(\0132\031.abb.eg"
  "m.wrapper.External\"]\n\007Planned\022%\n\005robot\030\001"
  " \001(\0132\026.abb.egm.wrapper.Robot\022+\n\010external"
  "\030\002 \001(\0132\031.abb.egm.wrapper.External\"\261\001\n\005In"
  "put\022\'\n\006header\030\001 \001(\0132\027.abb.egm.wrapper.He"
  "ader\022+\n\010feedback\030\002 \001(\0132\031.abb.egm.wrapper"
  ".Feedback\022)\n\007planned\030\003 \001(\0132\030.abb.egm.wra"
  "pper.Planned\022\'\n\006status\030\004 \001(\0132\027.abb.egm.w"
  "rapper.Status\"\\\n\006Output\022%\n\005robot\030\001 \001(\0132\026"
  ".abb.egm.wrapper.Robot\022+\n\010external\030\002 \001(\013"
  "2\031.abb.egm.wrapper.External"
,
  "egm_wrapper.proto", &assign_descriptors_table_egm_5fwrapper_2eproto, 1987,
};

void AddDescriptors_egm_5fwrapper_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_egm_5fwrapper_2eproto, deps, 0);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_egm_5fwrapper_2eproto = []() { AddDescriptors_egm_5fwrapper_2eproto(); return true; }();
namespace abb {
namespace egm {
namespace wrapper {
const ::google::protobuf::EnumDescriptor* Header_MessageType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_egm_5fwrapper_2eproto);
  return file_level_enum_descriptors_egm_5fwrapper_2eproto[0];
}
bool Header_MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Header_MessageType Header::UNDEFINED;
const Header_MessageType Header::DATA;
const Header_MessageType Header::MessageType_MIN;
const Header_MessageType Header::MessageType_MAX;
const int Header::MessageType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Status_EGMState_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_egm_5fwrapper_2eproto);
  return file_level_enum_descriptors_egm_5fwrapper_2eproto[1];
}
bool Status_EGMState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Status_EGMState Status::EGM_UNDEFINED;
const Status_EGMState Status::EGM_ERROR;
const Status_EGMState Status::EGM_STOPPED;
const Status_EGMState Status::EGM_RUNNING;
const Status_EGMState Status::EGMState_MIN;
const Status_EGMState Status::EGMState_MAX;
const int Status::EGMState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Status_MotorState_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_egm_5fwrapper_2eproto);
  return file_level_enum_descriptors_egm_5fwrapper_2eproto[2];
}
bool Status_MotorState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Status_MotorState Status::MOTORS_UNDEFINED;
const Status_MotorState Status::MOTORS_ON;
const Status_MotorState Status::MOTORS_OFF;
const Status_MotorState Status::MotorState_MIN;
const Status_MotorState Status::MotorState_MAX;
const int Status::MotorState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Status_RAPIDExecutionState_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_egm_5fwrapper_2eproto);
  return file_level_enum_descriptors_egm_5fwrapper_2eproto[3];
}
bool Status_RAPIDExecutionState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Status_RAPIDExecutionState Status::RAPID_UNDEFINED;
const Status_RAPIDExecutionState Status::RAPID_STOPPED;
const Status_RAPIDExecutionState Status::RAPID_RUNNING;
const Status_RAPIDExecutionState Status::RAPIDExecutionState_MIN;
const Status_RAPIDExecutionState Status::RAPIDExecutionState_MAX;
const int Status::RAPIDExecutionState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

void Header::InitAsDefaultInstance() {
}
class Header::HasBitSetters {
 public:
  static void set_has_sequance_number(Header* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_time_stamp(Header* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_message_type(Header* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Header::kSequanceNumberFieldNumber;
const int Header::kTimeStampFieldNumber;
const int Header::kMessageTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Header::Header()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Header)
}
Header::Header(const Header& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&sequance_number_, &from.sequance_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&message_type_) -
    reinterpret_cast<char*>(&sequance_number_)) + sizeof(message_type_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Header)
}

void Header::SharedCtor() {
  ::memset(&sequance_number_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&message_type_) -
      reinterpret_cast<char*>(&sequance_number_)) + sizeof(message_type_));
}

Header::~Header() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Header)
  SharedDtor();
}

void Header::SharedDtor() {
}

void Header::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Header& Header::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Header_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void Header::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&sequance_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&message_type_) -
        reinterpret_cast<char*>(&sequance_number_)) + sizeof(message_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Header::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Header*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 sequance_number = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::uint32 value = val;
        msg->set_sequance_number(value);
        break;
      }
      // optional uint32 time_stamp = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::uint32 value = val;
        msg->set_time_stamp(value);
        break;
      }
      // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::abb::egm::wrapper::Header_MessageType_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(3, val, msg->mutable_unknown_fields());
          break;
        }
        ::abb::egm::wrapper::Header_MessageType value = static_cast<::abb::egm::wrapper::Header_MessageType>(val);
        msg->set_message_type(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Header::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Header)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sequance_number = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_sequance_number(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequance_number_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 time_stamp = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_time_stamp(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Header_MessageType_IsValid(value)) {
            set_message_type(static_cast< ::abb::egm::wrapper::Header_MessageType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Header)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Header)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Header::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sequance_number = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sequance_number(), output);
  }

  // optional uint32 time_stamp = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->message_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Header)
}

::google::protobuf::uint8* Header::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Header)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sequance_number = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sequance_number(), target);
  }

  // optional uint32 time_stamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->message_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Header)
  return target;
}

size_t Header::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Header)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 sequance_number = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequance_number());
    }

    // optional uint32 time_stamp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // optional .abb.egm.wrapper.Header.MessageType message_type = 3 [default = UNDEFINED];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->message_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Header::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Header)
  GOOGLE_DCHECK_NE(&from, this);
  const Header* source =
      ::google::protobuf::DynamicCastToGenerated<Header>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Header)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Header)
    MergeFrom(*source);
  }
}

void Header::MergeFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Header)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      sequance_number_ = from.sequance_number_;
    }
    if (cached_has_bits & 0x00000002u) {
      time_stamp_ = from.time_stamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      message_type_ = from.message_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Header::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Header::CopyFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Header::IsInitialized() const {
  return true;
}

void Header::Swap(Header* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Header::InternalSwap(Header* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(sequance_number_, other->sequance_number_);
  swap(time_stamp_, other->time_stamp_);
  swap(message_type_, other->message_type_);
}

::google::protobuf::Metadata Header::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Status::InitAsDefaultInstance() {
}
class Status::HasBitSetters {
 public:
  static void set_has_egm_convergence_met(Status* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_egm_state(Status* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_motor_state(Status* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_rapid_execution_state(Status* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Status::kEgmConvergenceMetFieldNumber;
const int Status::kEgmStateFieldNumber;
const int Status::kMotorStateFieldNumber;
const int Status::kRapidExecutionStateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Status::Status()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Status)
}
Status::Status(const Status& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&egm_convergence_met_, &from.egm_convergence_met_,
    static_cast<size_t>(reinterpret_cast<char*>(&rapid_execution_state_) -
    reinterpret_cast<char*>(&egm_convergence_met_)) + sizeof(rapid_execution_state_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Status)
}

void Status::SharedCtor() {
  ::memset(&egm_convergence_met_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rapid_execution_state_) -
      reinterpret_cast<char*>(&egm_convergence_met_)) + sizeof(rapid_execution_state_));
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Status)
  SharedDtor();
}

void Status::SharedDtor() {
}

void Status::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Status& Status::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Status_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void Status::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Status)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&egm_convergence_met_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rapid_execution_state_) -
        reinterpret_cast<char*>(&egm_convergence_met_)) + sizeof(rapid_execution_state_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Status::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Status*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bool egm_convergence_met = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        bool value = val;
        msg->set_egm_convergence_met(value);
        break;
      }
      // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::abb::egm::wrapper::Status_EGMState_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(2, val, msg->mutable_unknown_fields());
          break;
        }
        ::abb::egm::wrapper::Status_EGMState value = static_cast<::abb::egm::wrapper::Status_EGMState>(val);
        msg->set_egm_state(value);
        break;
      }
      // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::abb::egm::wrapper::Status_MotorState_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(3, val, msg->mutable_unknown_fields());
          break;
        }
        ::abb::egm::wrapper::Status_MotorState value = static_cast<::abb::egm::wrapper::Status_MotorState>(val);
        msg->set_motor_state(value);
        break;
      }
      // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        if (!::abb::egm::wrapper::Status_RAPIDExecutionState_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(4, val, msg->mutable_unknown_fields());
          break;
        }
        ::abb::egm::wrapper::Status_RAPIDExecutionState value = static_cast<::abb::egm::wrapper::Status_RAPIDExecutionState>(val);
        msg->set_rapid_execution_state(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Status::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Status)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool egm_convergence_met = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_egm_convergence_met(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &egm_convergence_met_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Status_EGMState_IsValid(value)) {
            set_egm_state(static_cast< ::abb::egm::wrapper::Status_EGMState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Status_MotorState_IsValid(value)) {
            set_motor_state(static_cast< ::abb::egm::wrapper::Status_MotorState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::abb::egm::wrapper::Status_RAPIDExecutionState_IsValid(value)) {
            set_rapid_execution_state(static_cast< ::abb::egm::wrapper::Status_RAPIDExecutionState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast<::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Status)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Status)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Status::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Status)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool egm_convergence_met = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->egm_convergence_met(), output);
  }

  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->egm_state(), output);
  }

  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->motor_state(), output);
  }

  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->rapid_execution_state(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Status)
}

::google::protobuf::uint8* Status::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Status)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool egm_convergence_met = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->egm_convergence_met(), target);
  }

  // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->egm_state(), target);
  }

  // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->motor_state(), target);
  }

  // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->rapid_execution_state(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Status)
  return target;
}

size_t Status::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Status)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bool egm_convergence_met = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional .abb.egm.wrapper.Status.EGMState egm_state = 2 [default = EGM_UNDEFINED];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->egm_state());
    }

    // optional .abb.egm.wrapper.Status.MotorState motor_state = 3 [default = MOTORS_UNDEFINED];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->motor_state());
    }

    // optional .abb.egm.wrapper.Status.RAPIDExecutionState rapid_execution_state = 4 [default = RAPID_UNDEFINED];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rapid_execution_state());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Status::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Status)
  GOOGLE_DCHECK_NE(&from, this);
  const Status* source =
      ::google::protobuf::DynamicCastToGenerated<Status>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Status)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Status)
    MergeFrom(*source);
  }
}

void Status::MergeFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Status)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      egm_convergence_met_ = from.egm_convergence_met_;
    }
    if (cached_has_bits & 0x00000002u) {
      egm_state_ = from.egm_state_;
    }
    if (cached_has_bits & 0x00000004u) {
      motor_state_ = from.motor_state_;
    }
    if (cached_has_bits & 0x00000008u) {
      rapid_execution_state_ = from.rapid_execution_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Status::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Status::CopyFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {
  return true;
}

void Status::Swap(Status* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Status::InternalSwap(Status* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(egm_convergence_met_, other->egm_convergence_met_);
  swap(egm_state_, other->egm_state_);
  swap(motor_state_, other->motor_state_);
  swap(rapid_execution_state_, other->rapid_execution_state_);
}

::google::protobuf::Metadata Status::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Joints::InitAsDefaultInstance() {
}
class Joints::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Joints::kValuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Joints::Joints()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Joints)
}
Joints::Joints(const Joints& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      values_(from.values_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Joints)
}

void Joints::SharedCtor() {
}

Joints::~Joints() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Joints)
  SharedDtor();
}

void Joints::SharedDtor() {
}

void Joints::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Joints& Joints::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Joints_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void Joints::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Joints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Joints::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Joints*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated double values = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) == 9) {
          do {
            double val;
            ::std::memcpy(&val, ptr, 8);
            ptr += 8;
            msg->add_values(val);
            if (ptr >= end) break;
          } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 9 && (ptr += 1));
          break;
        } else if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::PackedDoubleParser;
        object = msg->mutable_values();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Joints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Joints)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double values = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 9u, input, this->mutable_values())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_values())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Joints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Joints)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Joints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Joints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double values = 1;
  for (int i = 0, n = this->values_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      1, this->values(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Joints)
}

::google::protobuf::uint8* Joints::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Joints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double values = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteDoubleToArray(1, this->values_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Joints)
  return target;
}

size_t Joints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Joints)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double values = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->values_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->values_size());
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Joints::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Joints)
  GOOGLE_DCHECK_NE(&from, this);
  const Joints* source =
      ::google::protobuf::DynamicCastToGenerated<Joints>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Joints)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Joints)
    MergeFrom(*source);
  }
}

void Joints::MergeFrom(const Joints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Joints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
}

void Joints::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Joints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Joints::CopyFrom(const Joints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Joints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Joints::IsInitialized() const {
  return true;
}

void Joints::Swap(Joints* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Joints::InternalSwap(Joints* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  values_.InternalSwap(&other->values_);
}

::google::protobuf::Metadata Joints::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void JointSpace::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_JointSpace_default_instance_._instance.get_mutable()->position_ = const_cast< ::abb::egm::wrapper::Joints*>(
      ::abb::egm::wrapper::Joints::internal_default_instance());
  ::abb::egm::wrapper::_JointSpace_default_instance_._instance.get_mutable()->velocity_ = const_cast< ::abb::egm::wrapper::Joints*>(
      ::abb::egm::wrapper::Joints::internal_default_instance());
}
class JointSpace::HasBitSetters {
 public:
  static const ::abb::egm::wrapper::Joints& position(const JointSpace* msg);
  static void set_has_position(JointSpace* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::abb::egm::wrapper::Joints& velocity(const JointSpace* msg);
  static void set_has_velocity(JointSpace* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::abb::egm::wrapper::Joints&
JointSpace::HasBitSetters::position(const JointSpace* msg) {
  return *msg->position_;
}
const ::abb::egm::wrapper::Joints&
JointSpace::HasBitSetters::velocity(const JointSpace* msg) {
  return *msg->velocity_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int JointSpace::kPositionFieldNumber;
const int JointSpace::kVelocityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

JointSpace::JointSpace()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.JointSpace)
}
JointSpace::JointSpace(const JointSpace& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::abb::egm::wrapper::Joints(*from.position_);
  } else {
    position_ = NULL;
  }
  if (from.has_velocity()) {
    velocity_ = new ::abb::egm::wrapper::Joints(*from.velocity_);
  } else {
    velocity_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.JointSpace)
}

void JointSpace::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_JointSpace_egm_5fwrapper_2eproto.base);
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&velocity_) -
      reinterpret_cast<char*>(&position_)) + sizeof(velocity_));
}

JointSpace::~JointSpace() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.JointSpace)
  SharedDtor();
}

void JointSpace::SharedDtor() {
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete velocity_;
}

void JointSpace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const JointSpace& JointSpace::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_JointSpace_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void JointSpace::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.JointSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(position_ != NULL);
      position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(velocity_ != NULL);
      velocity_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* JointSpace::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<JointSpace*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.wrapper.Joints position = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Joints::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .abb.egm.wrapper.Joints velocity = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Joints::_InternalParse;
        object = msg->mutable_velocity();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool JointSpace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.JointSpace)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Joints position = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Joints velocity = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.JointSpace)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.JointSpace)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void JointSpace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.JointSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Joints position = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::position(this), output);
  }

  // optional .abb.egm.wrapper.Joints velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::velocity(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.JointSpace)
}

::google::protobuf::uint8* JointSpace::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.JointSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Joints position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::position(this), deterministic, target);
  }

  // optional .abb.egm.wrapper.Joints velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::velocity(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.JointSpace)
  return target;
}

size_t JointSpace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.JointSpace)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.egm.wrapper.Joints position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *position_);
    }

    // optional .abb.egm.wrapper.Joints velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *velocity_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JointSpace::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.JointSpace)
  GOOGLE_DCHECK_NE(&from, this);
  const JointSpace* source =
      ::google::protobuf::DynamicCastToGenerated<JointSpace>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.JointSpace)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.JointSpace)
    MergeFrom(*source);
  }
}

void JointSpace::MergeFrom(const JointSpace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.JointSpace)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_position()->::abb::egm::wrapper::Joints::MergeFrom(from.position());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_velocity()->::abb::egm::wrapper::Joints::MergeFrom(from.velocity());
    }
  }
}

void JointSpace::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.JointSpace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JointSpace::CopyFrom(const JointSpace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.JointSpace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JointSpace::IsInitialized() const {
  return true;
}

void JointSpace::Swap(JointSpace* other) {
  if (other == this) return;
  InternalSwap(other);
}
void JointSpace::InternalSwap(JointSpace* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(position_, other->position_);
  swap(velocity_, other->velocity_);
}

::google::protobuf::Metadata JointSpace::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Cartesian::InitAsDefaultInstance() {
}
class Cartesian::HasBitSetters {
 public:
  static void set_has_x(Cartesian* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_y(Cartesian* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_z(Cartesian* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Cartesian::kXFieldNumber;
const int Cartesian::kYFieldNumber;
const int Cartesian::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Cartesian::Cartesian()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Cartesian)
}
Cartesian::Cartesian(const Cartesian& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Cartesian)
}

void Cartesian::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Cartesian::~Cartesian() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Cartesian)
  SharedDtor();
}

void Cartesian::SharedDtor() {
}

void Cartesian::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Cartesian& Cartesian::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Cartesian_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void Cartesian::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Cartesian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Cartesian::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Cartesian*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_x(val);
        break;
      }
      // optional double y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_y(val);
        break;
      }
      // optional double z = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_z(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Cartesian::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Cartesian)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_z(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Cartesian)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Cartesian)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Cartesian::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Cartesian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Cartesian)
}

::google::protobuf::uint8* Cartesian::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Cartesian)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Cartesian)
  return target;
}

size_t Cartesian::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Cartesian)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Cartesian::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Cartesian)
  GOOGLE_DCHECK_NE(&from, this);
  const Cartesian* source =
      ::google::protobuf::DynamicCastToGenerated<Cartesian>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Cartesian)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Cartesian)
    MergeFrom(*source);
  }
}

void Cartesian::MergeFrom(const Cartesian& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Cartesian)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Cartesian::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Cartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cartesian::CopyFrom(const Cartesian& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Cartesian)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cartesian::IsInitialized() const {
  return true;
}

void Cartesian::Swap(Cartesian* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Cartesian::InternalSwap(Cartesian* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
}

::google::protobuf::Metadata Cartesian::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Euler::InitAsDefaultInstance() {
}
class Euler::HasBitSetters {
 public:
  static void set_has_x(Euler* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_y(Euler* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_z(Euler* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Euler::kXFieldNumber;
const int Euler::kYFieldNumber;
const int Euler::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Euler::Euler()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Euler)
}
Euler::Euler(const Euler& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Euler)
}

void Euler::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Euler::~Euler() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Euler)
  SharedDtor();
}

void Euler::SharedDtor() {
}

void Euler::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Euler& Euler::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Euler_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void Euler::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Euler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Euler::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Euler*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_x(val);
        break;
      }
      // optional double y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_y(val);
        break;
      }
      // optional double z = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_z(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Euler::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Euler)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_x(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_y(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_z(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Euler)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Euler)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Euler::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Euler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Euler)
}

::google::protobuf::uint8* Euler::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Euler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x(), target);
  }

  // optional double y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y(), target);
  }

  // optional double z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Euler)
  return target;
}

size_t Euler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Euler)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Euler::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Euler)
  GOOGLE_DCHECK_NE(&from, this);
  const Euler* source =
      ::google::protobuf::DynamicCastToGenerated<Euler>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Euler)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Euler)
    MergeFrom(*source);
  }
}

void Euler::MergeFrom(const Euler& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Euler)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Euler::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Euler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Euler::CopyFrom(const Euler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Euler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Euler::IsInitialized() const {
  return true;
}

void Euler::Swap(Euler* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Euler::InternalSwap(Euler* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
}

::google::protobuf::Metadata Euler::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Quaternion::InitAsDefaultInstance() {
}
class Quaternion::HasBitSetters {
 public:
  static void set_has_u0(Quaternion* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_u1(Quaternion* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_u2(Quaternion* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_u3(Quaternion* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Quaternion::kU0FieldNumber;
const int Quaternion::kU1FieldNumber;
const int Quaternion::kU2FieldNumber;
const int Quaternion::kU3FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Quaternion::Quaternion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Quaternion)
}
Quaternion::Quaternion(const Quaternion& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&u0_, &from.u0_,
    static_cast<size_t>(reinterpret_cast<char*>(&u3_) -
    reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Quaternion)
}

void Quaternion::SharedCtor() {
  ::memset(&u0_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&u3_) -
      reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
}

Quaternion::~Quaternion() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Quaternion)
  SharedDtor();
}

void Quaternion::SharedDtor() {
}

void Quaternion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Quaternion& Quaternion::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Quaternion_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Quaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&u0_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&u3_) -
        reinterpret_cast<char*>(&u0_)) + sizeof(u3_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Quaternion::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Quaternion*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional double u0 = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 9) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_u0(val);
        break;
      }
      // optional double u1 = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 17) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_u1(val);
        break;
      }
      // optional double u2 = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 25) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_u2(val);
        break;
      }
      // optional double u3 = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 33) goto handle_unusual;
        double val;
        ::std::memcpy(&val, ptr, 8);
        ptr += 8;
        msg->set_u3(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Quaternion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Quaternion)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double u0 = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (9 & 0xFF)) {
          HasBitSetters::set_has_u0(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u0_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double u1 = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (17 & 0xFF)) {
          HasBitSetters::set_has_u1(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double u2 = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (25 & 0xFF)) {
          HasBitSetters::set_has_u2(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional double u3 = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (33 & 0xFF)) {
          HasBitSetters::set_has_u3(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &u3_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Quaternion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Quaternion)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Quaternion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Quaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double u0 = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->u0(), output);
  }

  // optional double u1 = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->u1(), output);
  }

  // optional double u2 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->u2(), output);
  }

  // optional double u3 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->u3(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Quaternion)
}

::google::protobuf::uint8* Quaternion::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Quaternion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double u0 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->u0(), target);
  }

  // optional double u1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->u1(), target);
  }

  // optional double u2 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->u2(), target);
  }

  // optional double u3 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->u3(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Quaternion)
  return target;
}

size_t Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Quaternion)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional double u0 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double u1 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double u2 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double u3 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Quaternion::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Quaternion)
  GOOGLE_DCHECK_NE(&from, this);
  const Quaternion* source =
      ::google::protobuf::DynamicCastToGenerated<Quaternion>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Quaternion)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Quaternion)
    MergeFrom(*source);
  }
}

void Quaternion::MergeFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Quaternion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      u0_ = from.u0_;
    }
    if (cached_has_bits & 0x00000002u) {
      u1_ = from.u1_;
    }
    if (cached_has_bits & 0x00000004u) {
      u2_ = from.u2_;
    }
    if (cached_has_bits & 0x00000008u) {
      u3_ = from.u3_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Quaternion::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Quaternion::CopyFrom(const Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quaternion::IsInitialized() const {
  return true;
}

void Quaternion::Swap(Quaternion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Quaternion::InternalSwap(Quaternion* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(u0_, other->u0_);
  swap(u1_, other->u1_);
  swap(u2_, other->u2_);
  swap(u3_, other->u3_);
}

::google::protobuf::Metadata Quaternion::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CartesianPose::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_CartesianPose_default_instance_._instance.get_mutable()->position_ = const_cast< ::abb::egm::wrapper::Cartesian*>(
      ::abb::egm::wrapper::Cartesian::internal_default_instance());
  ::abb::egm::wrapper::_CartesianPose_default_instance_._instance.get_mutable()->euler_ = const_cast< ::abb::egm::wrapper::Euler*>(
      ::abb::egm::wrapper::Euler::internal_default_instance());
  ::abb::egm::wrapper::_CartesianPose_default_instance_._instance.get_mutable()->quaternion_ = const_cast< ::abb::egm::wrapper::Quaternion*>(
      ::abb::egm::wrapper::Quaternion::internal_default_instance());
}
class CartesianPose::HasBitSetters {
 public:
  static const ::abb::egm::wrapper::Cartesian& position(const CartesianPose* msg);
  static void set_has_position(CartesianPose* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::abb::egm::wrapper::Euler& euler(const CartesianPose* msg);
  static void set_has_euler(CartesianPose* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::abb::egm::wrapper::Quaternion& quaternion(const CartesianPose* msg);
  static void set_has_quaternion(CartesianPose* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

const ::abb::egm::wrapper::Cartesian&
CartesianPose::HasBitSetters::position(const CartesianPose* msg) {
  return *msg->position_;
}
const ::abb::egm::wrapper::Euler&
CartesianPose::HasBitSetters::euler(const CartesianPose* msg) {
  return *msg->euler_;
}
const ::abb::egm::wrapper::Quaternion&
CartesianPose::HasBitSetters::quaternion(const CartesianPose* msg) {
  return *msg->quaternion_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CartesianPose::kPositionFieldNumber;
const int CartesianPose::kEulerFieldNumber;
const int CartesianPose::kQuaternionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CartesianPose::CartesianPose()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.CartesianPose)
}
CartesianPose::CartesianPose(const CartesianPose& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::abb::egm::wrapper::Cartesian(*from.position_);
  } else {
    position_ = NULL;
  }
  if (from.has_euler()) {
    euler_ = new ::abb::egm::wrapper::Euler(*from.euler_);
  } else {
    euler_ = NULL;
  }
  if (from.has_quaternion()) {
    quaternion_ = new ::abb::egm::wrapper::Quaternion(*from.quaternion_);
  } else {
    quaternion_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.CartesianPose)
}

void CartesianPose::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CartesianPose_egm_5fwrapper_2eproto.base);
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&quaternion_) -
      reinterpret_cast<char*>(&position_)) + sizeof(quaternion_));
}

CartesianPose::~CartesianPose() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.CartesianPose)
  SharedDtor();
}

void CartesianPose::SharedDtor() {
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete euler_;
  if (this != internal_default_instance()) delete quaternion_;
}

void CartesianPose::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CartesianPose& CartesianPose::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CartesianPose_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void CartesianPose::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.CartesianPose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(position_ != NULL);
      position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(euler_ != NULL);
      euler_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(quaternion_ != NULL);
      quaternion_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CartesianPose::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CartesianPose*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.wrapper.Cartesian position = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Cartesian::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .abb.egm.wrapper.Euler euler = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Euler::_InternalParse;
        object = msg->mutable_euler();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .abb.egm.wrapper.Quaternion quaternion = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Quaternion::_InternalParse;
        object = msg->mutable_quaternion();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CartesianPose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.CartesianPose)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Cartesian position = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Euler euler = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_euler()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Quaternion quaternion = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_quaternion()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.CartesianPose)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.CartesianPose)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CartesianPose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.CartesianPose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Cartesian position = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::position(this), output);
  }

  // optional .abb.egm.wrapper.Euler euler = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::euler(this), output);
  }

  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::quaternion(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.CartesianPose)
}

::google::protobuf::uint8* CartesianPose::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.CartesianPose)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Cartesian position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::position(this), deterministic, target);
  }

  // optional .abb.egm.wrapper.Euler euler = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::euler(this), deterministic, target);
  }

  // optional .abb.egm.wrapper.Quaternion quaternion = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::quaternion(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.CartesianPose)
  return target;
}

size_t CartesianPose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.CartesianPose)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .abb.egm.wrapper.Cartesian position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *position_);
    }

    // optional .abb.egm.wrapper.Euler euler = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *euler_);
    }

    // optional .abb.egm.wrapper.Quaternion quaternion = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *quaternion_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CartesianPose::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.CartesianPose)
  GOOGLE_DCHECK_NE(&from, this);
  const CartesianPose* source =
      ::google::protobuf::DynamicCastToGenerated<CartesianPose>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.CartesianPose)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.CartesianPose)
    MergeFrom(*source);
  }
}

void CartesianPose::MergeFrom(const CartesianPose& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.CartesianPose)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_position()->::abb::egm::wrapper::Cartesian::MergeFrom(from.position());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_euler()->::abb::egm::wrapper::Euler::MergeFrom(from.euler());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_quaternion()->::abb::egm::wrapper::Quaternion::MergeFrom(from.quaternion());
    }
  }
}

void CartesianPose::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.CartesianPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianPose::CopyFrom(const CartesianPose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.CartesianPose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianPose::IsInitialized() const {
  return true;
}

void CartesianPose::Swap(CartesianPose* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CartesianPose::InternalSwap(CartesianPose* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(position_, other->position_);
  swap(euler_, other->euler_);
  swap(quaternion_, other->quaternion_);
}

::google::protobuf::Metadata CartesianPose::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CartesianVelocity::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_CartesianVelocity_default_instance_._instance.get_mutable()->linear_ = const_cast< ::abb::egm::wrapper::Cartesian*>(
      ::abb::egm::wrapper::Cartesian::internal_default_instance());
  ::abb::egm::wrapper::_CartesianVelocity_default_instance_._instance.get_mutable()->angular_ = const_cast< ::abb::egm::wrapper::Euler*>(
      ::abb::egm::wrapper::Euler::internal_default_instance());
}
class CartesianVelocity::HasBitSetters {
 public:
  static const ::abb::egm::wrapper::Cartesian& linear(const CartesianVelocity* msg);
  static void set_has_linear(CartesianVelocity* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::abb::egm::wrapper::Euler& angular(const CartesianVelocity* msg);
  static void set_has_angular(CartesianVelocity* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::abb::egm::wrapper::Cartesian&
CartesianVelocity::HasBitSetters::linear(const CartesianVelocity* msg) {
  return *msg->linear_;
}
const ::abb::egm::wrapper::Euler&
CartesianVelocity::HasBitSetters::angular(const CartesianVelocity* msg) {
  return *msg->angular_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CartesianVelocity::kLinearFieldNumber;
const int CartesianVelocity::kAngularFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CartesianVelocity::CartesianVelocity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.CartesianVelocity)
}
CartesianVelocity::CartesianVelocity(const CartesianVelocity& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_linear()) {
    linear_ = new ::abb::egm::wrapper::Cartesian(*from.linear_);
  } else {
    linear_ = NULL;
  }
  if (from.has_angular()) {
    angular_ = new ::abb::egm::wrapper::Euler(*from.angular_);
  } else {
    angular_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.CartesianVelocity)
}

void CartesianVelocity::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CartesianVelocity_egm_5fwrapper_2eproto.base);
  ::memset(&linear_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&angular_) -
      reinterpret_cast<char*>(&linear_)) + sizeof(angular_));
}

CartesianVelocity::~CartesianVelocity() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.CartesianVelocity)
  SharedDtor();
}

void CartesianVelocity::SharedDtor() {
  if (this != internal_default_instance()) delete linear_;
  if (this != internal_default_instance()) delete angular_;
}

void CartesianVelocity::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CartesianVelocity& CartesianVelocity::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CartesianVelocity_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void CartesianVelocity::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.CartesianVelocity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(linear_ != NULL);
      linear_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(angular_ != NULL);
      angular_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CartesianVelocity::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CartesianVelocity*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.wrapper.Cartesian linear = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Cartesian::_InternalParse;
        object = msg->mutable_linear();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .abb.egm.wrapper.Euler angular = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Euler::_InternalParse;
        object = msg->mutable_angular();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CartesianVelocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.CartesianVelocity)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Cartesian linear = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_linear()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Euler angular = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_angular()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.CartesianVelocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.CartesianVelocity)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CartesianVelocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.CartesianVelocity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Cartesian linear = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::linear(this), output);
  }

  // optional .abb.egm.wrapper.Euler angular = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::angular(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.CartesianVelocity)
}

::google::protobuf::uint8* CartesianVelocity::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.CartesianVelocity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Cartesian linear = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::linear(this), deterministic, target);
  }

  // optional .abb.egm.wrapper.Euler angular = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::angular(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.CartesianVelocity)
  return target;
}

size_t CartesianVelocity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.CartesianVelocity)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.egm.wrapper.Cartesian linear = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *linear_);
    }

    // optional .abb.egm.wrapper.Euler angular = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *angular_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CartesianVelocity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.CartesianVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  const CartesianVelocity* source =
      ::google::protobuf::DynamicCastToGenerated<CartesianVelocity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.CartesianVelocity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.CartesianVelocity)
    MergeFrom(*source);
  }
}

void CartesianVelocity::MergeFrom(const CartesianVelocity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.CartesianVelocity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_linear()->::abb::egm::wrapper::Cartesian::MergeFrom(from.linear());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_angular()->::abb::egm::wrapper::Euler::MergeFrom(from.angular());
    }
  }
}

void CartesianVelocity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.CartesianVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianVelocity::CopyFrom(const CartesianVelocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.CartesianVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianVelocity::IsInitialized() const {
  return true;
}

void CartesianVelocity::Swap(CartesianVelocity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CartesianVelocity::InternalSwap(CartesianVelocity* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(linear_, other->linear_);
  swap(angular_, other->angular_);
}

::google::protobuf::Metadata CartesianVelocity::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void CartesianSpace::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_CartesianSpace_default_instance_._instance.get_mutable()->pose_ = const_cast< ::abb::egm::wrapper::CartesianPose*>(
      ::abb::egm::wrapper::CartesianPose::internal_default_instance());
  ::abb::egm::wrapper::_CartesianSpace_default_instance_._instance.get_mutable()->velocity_ = const_cast< ::abb::egm::wrapper::CartesianVelocity*>(
      ::abb::egm::wrapper::CartesianVelocity::internal_default_instance());
}
class CartesianSpace::HasBitSetters {
 public:
  static const ::abb::egm::wrapper::CartesianPose& pose(const CartesianSpace* msg);
  static void set_has_pose(CartesianSpace* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::abb::egm::wrapper::CartesianVelocity& velocity(const CartesianSpace* msg);
  static void set_has_velocity(CartesianSpace* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::abb::egm::wrapper::CartesianPose&
CartesianSpace::HasBitSetters::pose(const CartesianSpace* msg) {
  return *msg->pose_;
}
const ::abb::egm::wrapper::CartesianVelocity&
CartesianSpace::HasBitSetters::velocity(const CartesianSpace* msg) {
  return *msg->velocity_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CartesianSpace::kPoseFieldNumber;
const int CartesianSpace::kVelocityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CartesianSpace::CartesianSpace()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.CartesianSpace)
}
CartesianSpace::CartesianSpace(const CartesianSpace& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_pose()) {
    pose_ = new ::abb::egm::wrapper::CartesianPose(*from.pose_);
  } else {
    pose_ = NULL;
  }
  if (from.has_velocity()) {
    velocity_ = new ::abb::egm::wrapper::CartesianVelocity(*from.velocity_);
  } else {
    velocity_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.CartesianSpace)
}

void CartesianSpace::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CartesianSpace_egm_5fwrapper_2eproto.base);
  ::memset(&pose_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&velocity_) -
      reinterpret_cast<char*>(&pose_)) + sizeof(velocity_));
}

CartesianSpace::~CartesianSpace() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.CartesianSpace)
  SharedDtor();
}

void CartesianSpace::SharedDtor() {
  if (this != internal_default_instance()) delete pose_;
  if (this != internal_default_instance()) delete velocity_;
}

void CartesianSpace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CartesianSpace& CartesianSpace::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CartesianSpace_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void CartesianSpace::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.CartesianSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(pose_ != NULL);
      pose_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(velocity_ != NULL);
      velocity_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CartesianSpace::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CartesianSpace*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.wrapper.CartesianPose pose = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::CartesianPose::_InternalParse;
        object = msg->mutable_pose();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::CartesianVelocity::_InternalParse;
        object = msg->mutable_velocity();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CartesianSpace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.CartesianSpace)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.CartesianPose pose = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_velocity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.CartesianSpace)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.CartesianSpace)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CartesianSpace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.CartesianSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::pose(this), output);
  }

  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::velocity(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.CartesianSpace)
}

::google::protobuf::uint8* CartesianSpace::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.CartesianSpace)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.CartesianPose pose = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::pose(this), deterministic, target);
  }

  // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::velocity(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.CartesianSpace)
  return target;
}

size_t CartesianSpace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.CartesianSpace)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.egm.wrapper.CartesianPose pose = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *pose_);
    }

    // optional .abb.egm.wrapper.CartesianVelocity velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *velocity_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CartesianSpace::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.CartesianSpace)
  GOOGLE_DCHECK_NE(&from, this);
  const CartesianSpace* source =
      ::google::protobuf::DynamicCastToGenerated<CartesianSpace>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.CartesianSpace)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.CartesianSpace)
    MergeFrom(*source);
  }
}

void CartesianSpace::MergeFrom(const CartesianSpace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.CartesianSpace)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_pose()->::abb::egm::wrapper::CartesianPose::MergeFrom(from.pose());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_velocity()->::abb::egm::wrapper::CartesianVelocity::MergeFrom(from.velocity());
    }
  }
}

void CartesianSpace::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.CartesianSpace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartesianSpace::CopyFrom(const CartesianSpace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.CartesianSpace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartesianSpace::IsInitialized() const {
  return true;
}

void CartesianSpace::Swap(CartesianSpace* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CartesianSpace::InternalSwap(CartesianSpace* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(pose_, other->pose_);
  swap(velocity_, other->velocity_);
}

::google::protobuf::Metadata CartesianSpace::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Robot::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Robot_default_instance_._instance.get_mutable()->joints_ = const_cast< ::abb::egm::wrapper::JointSpace*>(
      ::abb::egm::wrapper::JointSpace::internal_default_instance());
  ::abb::egm::wrapper::_Robot_default_instance_._instance.get_mutable()->cartesian_ = const_cast< ::abb::egm::wrapper::CartesianSpace*>(
      ::abb::egm::wrapper::CartesianSpace::internal_default_instance());
}
class Robot::HasBitSetters {
 public:
  static const ::abb::egm::wrapper::JointSpace& joints(const Robot* msg);
  static void set_has_joints(Robot* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::abb::egm::wrapper::CartesianSpace& cartesian(const Robot* msg);
  static void set_has_cartesian(Robot* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::abb::egm::wrapper::JointSpace&
Robot::HasBitSetters::joints(const Robot* msg) {
  return *msg->joints_;
}
const ::abb::egm::wrapper::CartesianSpace&
Robot::HasBitSetters::cartesian(const Robot* msg) {
  return *msg->cartesian_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Robot::kJointsFieldNumber;
const int Robot::kCartesianFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Robot::Robot()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Robot)
}
Robot::Robot(const Robot& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_joints()) {
    joints_ = new ::abb::egm::wrapper::JointSpace(*from.joints_);
  } else {
    joints_ = NULL;
  }
  if (from.has_cartesian()) {
    cartesian_ = new ::abb::egm::wrapper::CartesianSpace(*from.cartesian_);
  } else {
    cartesian_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Robot)
}

void Robot::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Robot_egm_5fwrapper_2eproto.base);
  ::memset(&joints_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cartesian_) -
      reinterpret_cast<char*>(&joints_)) + sizeof(cartesian_));
}

Robot::~Robot() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Robot)
  SharedDtor();
}

void Robot::SharedDtor() {
  if (this != internal_default_instance()) delete joints_;
  if (this != internal_default_instance()) delete cartesian_;
}

void Robot::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Robot& Robot::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Robot_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void Robot::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Robot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(joints_ != NULL);
      joints_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(cartesian_ != NULL);
      cartesian_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Robot::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Robot*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.wrapper.JointSpace joints = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::JointSpace::_InternalParse;
        object = msg->mutable_joints();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::CartesianSpace::_InternalParse;
        object = msg->mutable_cartesian();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Robot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Robot)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.JointSpace joints = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_cartesian()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Robot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Robot)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Robot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Robot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::joints(this), output);
  }

  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::cartesian(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Robot)
}

::google::protobuf::uint8* Robot::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Robot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::joints(this), deterministic, target);
  }

  // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::cartesian(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Robot)
  return target;
}

size_t Robot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Robot)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.egm.wrapper.JointSpace joints = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *joints_);
    }

    // optional .abb.egm.wrapper.CartesianSpace cartesian = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *cartesian_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Robot::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Robot)
  GOOGLE_DCHECK_NE(&from, this);
  const Robot* source =
      ::google::protobuf::DynamicCastToGenerated<Robot>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Robot)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Robot)
    MergeFrom(*source);
  }
}

void Robot::MergeFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Robot)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_joints()->::abb::egm::wrapper::JointSpace::MergeFrom(from.joints());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_cartesian()->::abb::egm::wrapper::CartesianSpace::MergeFrom(from.cartesian());
    }
  }
}

void Robot::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Robot::CopyFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Robot::IsInitialized() const {
  return true;
}

void Robot::Swap(Robot* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Robot::InternalSwap(Robot* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(joints_, other->joints_);
  swap(cartesian_, other->cartesian_);
}

::google::protobuf::Metadata Robot::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void External::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_External_default_instance_._instance.get_mutable()->joints_ = const_cast< ::abb::egm::wrapper::JointSpace*>(
      ::abb::egm::wrapper::JointSpace::internal_default_instance());
}
class External::HasBitSetters {
 public:
  static const ::abb::egm::wrapper::JointSpace& joints(const External* msg);
  static void set_has_joints(External* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::abb::egm::wrapper::JointSpace&
External::HasBitSetters::joints(const External* msg) {
  return *msg->joints_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int External::kJointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

External::External()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.External)
}
External::External(const External& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_joints()) {
    joints_ = new ::abb::egm::wrapper::JointSpace(*from.joints_);
  } else {
    joints_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.External)
}

void External::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_External_egm_5fwrapper_2eproto.base);
  joints_ = NULL;
}

External::~External() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.External)
  SharedDtor();
}

void External::SharedDtor() {
  if (this != internal_default_instance()) delete joints_;
}

void External::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const External& External::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_External_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void External::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.External)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(joints_ != NULL);
    joints_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* External::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<External*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.wrapper.JointSpace joints = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::JointSpace::_InternalParse;
        object = msg->mutable_joints();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool External::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.External)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.JointSpace joints = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_joints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.External)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.External)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void External::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.External)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::joints(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.External)
}

::google::protobuf::uint8* External::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.External)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.JointSpace joints = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::joints(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.External)
  return target;
}

size_t External::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.External)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .abb.egm.wrapper.JointSpace joints = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *joints_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void External::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.External)
  GOOGLE_DCHECK_NE(&from, this);
  const External* source =
      ::google::protobuf::DynamicCastToGenerated<External>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.External)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.External)
    MergeFrom(*source);
  }
}

void External::MergeFrom(const External& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.External)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_joints()) {
    mutable_joints()->::abb::egm::wrapper::JointSpace::MergeFrom(from.joints());
  }
}

void External::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.External)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void External::CopyFrom(const External& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.External)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool External::IsInitialized() const {
  return true;
}

void External::Swap(External* other) {
  if (other == this) return;
  InternalSwap(other);
}
void External::InternalSwap(External* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(joints_, other->joints_);
}

::google::protobuf::Metadata External::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Feedback::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Feedback_default_instance_._instance.get_mutable()->robot_ = const_cast< ::abb::egm::wrapper::Robot*>(
      ::abb::egm::wrapper::Robot::internal_default_instance());
  ::abb::egm::wrapper::_Feedback_default_instance_._instance.get_mutable()->external_ = const_cast< ::abb::egm::wrapper::External*>(
      ::abb::egm::wrapper::External::internal_default_instance());
}
class Feedback::HasBitSetters {
 public:
  static const ::abb::egm::wrapper::Robot& robot(const Feedback* msg);
  static void set_has_robot(Feedback* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::abb::egm::wrapper::External& external(const Feedback* msg);
  static void set_has_external(Feedback* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::abb::egm::wrapper::Robot&
Feedback::HasBitSetters::robot(const Feedback* msg) {
  return *msg->robot_;
}
const ::abb::egm::wrapper::External&
Feedback::HasBitSetters::external(const Feedback* msg) {
  return *msg->external_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Feedback::kRobotFieldNumber;
const int Feedback::kExternalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Feedback::Feedback()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Feedback)
}
Feedback::Feedback(const Feedback& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_robot()) {
    robot_ = new ::abb::egm::wrapper::Robot(*from.robot_);
  } else {
    robot_ = NULL;
  }
  if (from.has_external()) {
    external_ = new ::abb::egm::wrapper::External(*from.external_);
  } else {
    external_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Feedback)
}

void Feedback::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Feedback_egm_5fwrapper_2eproto.base);
  ::memset(&robot_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&external_) -
      reinterpret_cast<char*>(&robot_)) + sizeof(external_));
}

Feedback::~Feedback() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Feedback)
  SharedDtor();
}

void Feedback::SharedDtor() {
  if (this != internal_default_instance()) delete robot_;
  if (this != internal_default_instance()) delete external_;
}

void Feedback::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Feedback& Feedback::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Feedback_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void Feedback::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Feedback)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(robot_ != NULL);
      robot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(external_ != NULL);
      external_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Feedback::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Feedback*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Robot::_InternalParse;
        object = msg->mutable_robot();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::External::_InternalParse;
        object = msg->mutable_external();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Feedback::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Feedback)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Feedback)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Feedback)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Feedback::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Feedback)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::robot(this), output);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::external(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Feedback)
}

::google::protobuf::uint8* Feedback::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Feedback)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::robot(this), deterministic, target);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::external(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Feedback)
  return target;
}

size_t Feedback::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Feedback)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.egm.wrapper.Robot robot = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *robot_);
    }

    // optional .abb.egm.wrapper.External external = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *external_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Feedback::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Feedback)
  GOOGLE_DCHECK_NE(&from, this);
  const Feedback* source =
      ::google::protobuf::DynamicCastToGenerated<Feedback>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Feedback)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Feedback)
    MergeFrom(*source);
  }
}

void Feedback::MergeFrom(const Feedback& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Feedback)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_robot()->::abb::egm::wrapper::Robot::MergeFrom(from.robot());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_external()->::abb::egm::wrapper::External::MergeFrom(from.external());
    }
  }
}

void Feedback::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Feedback)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Feedback::CopyFrom(const Feedback& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Feedback)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Feedback::IsInitialized() const {
  return true;
}

void Feedback::Swap(Feedback* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Feedback::InternalSwap(Feedback* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(robot_, other->robot_);
  swap(external_, other->external_);
}

::google::protobuf::Metadata Feedback::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Planned::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Planned_default_instance_._instance.get_mutable()->robot_ = const_cast< ::abb::egm::wrapper::Robot*>(
      ::abb::egm::wrapper::Robot::internal_default_instance());
  ::abb::egm::wrapper::_Planned_default_instance_._instance.get_mutable()->external_ = const_cast< ::abb::egm::wrapper::External*>(
      ::abb::egm::wrapper::External::internal_default_instance());
}
class Planned::HasBitSetters {
 public:
  static const ::abb::egm::wrapper::Robot& robot(const Planned* msg);
  static void set_has_robot(Planned* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::abb::egm::wrapper::External& external(const Planned* msg);
  static void set_has_external(Planned* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::abb::egm::wrapper::Robot&
Planned::HasBitSetters::robot(const Planned* msg) {
  return *msg->robot_;
}
const ::abb::egm::wrapper::External&
Planned::HasBitSetters::external(const Planned* msg) {
  return *msg->external_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Planned::kRobotFieldNumber;
const int Planned::kExternalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Planned::Planned()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Planned)
}
Planned::Planned(const Planned& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_robot()) {
    robot_ = new ::abb::egm::wrapper::Robot(*from.robot_);
  } else {
    robot_ = NULL;
  }
  if (from.has_external()) {
    external_ = new ::abb::egm::wrapper::External(*from.external_);
  } else {
    external_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Planned)
}

void Planned::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Planned_egm_5fwrapper_2eproto.base);
  ::memset(&robot_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&external_) -
      reinterpret_cast<char*>(&robot_)) + sizeof(external_));
}

Planned::~Planned() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Planned)
  SharedDtor();
}

void Planned::SharedDtor() {
  if (this != internal_default_instance()) delete robot_;
  if (this != internal_default_instance()) delete external_;
}

void Planned::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Planned& Planned::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Planned_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void Planned::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Planned)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(robot_ != NULL);
      robot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(external_ != NULL);
      external_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Planned::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Planned*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Robot::_InternalParse;
        object = msg->mutable_robot();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::External::_InternalParse;
        object = msg->mutable_external();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Planned::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Planned)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Planned)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Planned)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Planned::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Planned)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::robot(this), output);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::external(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Planned)
}

::google::protobuf::uint8* Planned::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Planned)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::robot(this), deterministic, target);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::external(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Planned)
  return target;
}

size_t Planned::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Planned)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.egm.wrapper.Robot robot = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *robot_);
    }

    // optional .abb.egm.wrapper.External external = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *external_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Planned::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Planned)
  GOOGLE_DCHECK_NE(&from, this);
  const Planned* source =
      ::google::protobuf::DynamicCastToGenerated<Planned>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Planned)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Planned)
    MergeFrom(*source);
  }
}

void Planned::MergeFrom(const Planned& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Planned)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_robot()->::abb::egm::wrapper::Robot::MergeFrom(from.robot());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_external()->::abb::egm::wrapper::External::MergeFrom(from.external());
    }
  }
}

void Planned::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Planned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Planned::CopyFrom(const Planned& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Planned)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Planned::IsInitialized() const {
  return true;
}

void Planned::Swap(Planned* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Planned::InternalSwap(Planned* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(robot_, other->robot_);
  swap(external_, other->external_);
}

::google::protobuf::Metadata Planned::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Input::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Input_default_instance_._instance.get_mutable()->header_ = const_cast< ::abb::egm::wrapper::Header*>(
      ::abb::egm::wrapper::Header::internal_default_instance());
  ::abb::egm::wrapper::_Input_default_instance_._instance.get_mutable()->feedback_ = const_cast< ::abb::egm::wrapper::Feedback*>(
      ::abb::egm::wrapper::Feedback::internal_default_instance());
  ::abb::egm::wrapper::_Input_default_instance_._instance.get_mutable()->planned_ = const_cast< ::abb::egm::wrapper::Planned*>(
      ::abb::egm::wrapper::Planned::internal_default_instance());
  ::abb::egm::wrapper::_Input_default_instance_._instance.get_mutable()->status_ = const_cast< ::abb::egm::wrapper::Status*>(
      ::abb::egm::wrapper::Status::internal_default_instance());
}
class Input::HasBitSetters {
 public:
  static const ::abb::egm::wrapper::Header& header(const Input* msg);
  static void set_has_header(Input* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::abb::egm::wrapper::Feedback& feedback(const Input* msg);
  static void set_has_feedback(Input* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static const ::abb::egm::wrapper::Planned& planned(const Input* msg);
  static void set_has_planned(Input* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::abb::egm::wrapper::Status& status(const Input* msg);
  static void set_has_status(Input* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

const ::abb::egm::wrapper::Header&
Input::HasBitSetters::header(const Input* msg) {
  return *msg->header_;
}
const ::abb::egm::wrapper::Feedback&
Input::HasBitSetters::feedback(const Input* msg) {
  return *msg->feedback_;
}
const ::abb::egm::wrapper::Planned&
Input::HasBitSetters::planned(const Input* msg) {
  return *msg->planned_;
}
const ::abb::egm::wrapper::Status&
Input::HasBitSetters::status(const Input* msg) {
  return *msg->status_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Input::kHeaderFieldNumber;
const int Input::kFeedbackFieldNumber;
const int Input::kPlannedFieldNumber;
const int Input::kStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Input::Input()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Input)
}
Input::Input(const Input& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::abb::egm::wrapper::Header(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_feedback()) {
    feedback_ = new ::abb::egm::wrapper::Feedback(*from.feedback_);
  } else {
    feedback_ = NULL;
  }
  if (from.has_planned()) {
    planned_ = new ::abb::egm::wrapper::Planned(*from.planned_);
  } else {
    planned_ = NULL;
  }
  if (from.has_status()) {
    status_ = new ::abb::egm::wrapper::Status(*from.status_);
  } else {
    status_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Input)
}

void Input::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Input_egm_5fwrapper_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&header_)) + sizeof(status_));
}

Input::~Input() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Input)
  SharedDtor();
}

void Input::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete feedback_;
  if (this != internal_default_instance()) delete planned_;
  if (this != internal_default_instance()) delete status_;
}

void Input::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Input& Input::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Input_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void Input::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Input)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != NULL);
      header_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(feedback_ != NULL);
      feedback_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(planned_ != NULL);
      planned_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(status_ != NULL);
      status_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Input::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Input*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.wrapper.Header header = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Header::_InternalParse;
        object = msg->mutable_header();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .abb.egm.wrapper.Feedback feedback = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Feedback::_InternalParse;
        object = msg->mutable_feedback();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .abb.egm.wrapper.Planned planned = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Planned::_InternalParse;
        object = msg->mutable_planned();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .abb.egm.wrapper.Status status = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Status::_InternalParse;
        object = msg->mutable_status();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Input::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Input)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Header header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Feedback feedback = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_feedback()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Planned planned = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_planned()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.Status status = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Input)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Input)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Input::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Input)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Header header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::header(this), output);
  }

  // optional .abb.egm.wrapper.Feedback feedback = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::feedback(this), output);
  }

  // optional .abb.egm.wrapper.Planned planned = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::planned(this), output);
  }

  // optional .abb.egm.wrapper.Status status = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, HasBitSetters::status(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Input)
}

::google::protobuf::uint8* Input::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Input)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Header header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::header(this), deterministic, target);
  }

  // optional .abb.egm.wrapper.Feedback feedback = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::feedback(this), deterministic, target);
  }

  // optional .abb.egm.wrapper.Planned planned = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::planned(this), deterministic, target);
  }

  // optional .abb.egm.wrapper.Status status = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, HasBitSetters::status(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Input)
  return target;
}

size_t Input::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Input)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .abb.egm.wrapper.Header header = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *header_);
    }

    // optional .abb.egm.wrapper.Feedback feedback = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *feedback_);
    }

    // optional .abb.egm.wrapper.Planned planned = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *planned_);
    }

    // optional .abb.egm.wrapper.Status status = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *status_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Input::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Input)
  GOOGLE_DCHECK_NE(&from, this);
  const Input* source =
      ::google::protobuf::DynamicCastToGenerated<Input>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Input)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Input)
    MergeFrom(*source);
  }
}

void Input::MergeFrom(const Input& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Input)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_header()->::abb::egm::wrapper::Header::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_feedback()->::abb::egm::wrapper::Feedback::MergeFrom(from.feedback());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_planned()->::abb::egm::wrapper::Planned::MergeFrom(from.planned());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_status()->::abb::egm::wrapper::Status::MergeFrom(from.status());
    }
  }
}

void Input::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Input)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Input::CopyFrom(const Input& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Input)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Input::IsInitialized() const {
  return true;
}

void Input::Swap(Input* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Input::InternalSwap(Input* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(header_, other->header_);
  swap(feedback_, other->feedback_);
  swap(planned_, other->planned_);
  swap(status_, other->status_);
}

::google::protobuf::Metadata Input::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Output::InitAsDefaultInstance() {
  ::abb::egm::wrapper::_Output_default_instance_._instance.get_mutable()->robot_ = const_cast< ::abb::egm::wrapper::Robot*>(
      ::abb::egm::wrapper::Robot::internal_default_instance());
  ::abb::egm::wrapper::_Output_default_instance_._instance.get_mutable()->external_ = const_cast< ::abb::egm::wrapper::External*>(
      ::abb::egm::wrapper::External::internal_default_instance());
}
class Output::HasBitSetters {
 public:
  static const ::abb::egm::wrapper::Robot& robot(const Output* msg);
  static void set_has_robot(Output* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::abb::egm::wrapper::External& external(const Output* msg);
  static void set_has_external(Output* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::abb::egm::wrapper::Robot&
Output::HasBitSetters::robot(const Output* msg) {
  return *msg->robot_;
}
const ::abb::egm::wrapper::External&
Output::HasBitSetters::external(const Output* msg) {
  return *msg->external_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Output::kRobotFieldNumber;
const int Output::kExternalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Output::Output()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:abb.egm.wrapper.Output)
}
Output::Output(const Output& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_robot()) {
    robot_ = new ::abb::egm::wrapper::Robot(*from.robot_);
  } else {
    robot_ = NULL;
  }
  if (from.has_external()) {
    external_ = new ::abb::egm::wrapper::External(*from.external_);
  } else {
    external_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:abb.egm.wrapper.Output)
}

void Output::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Output_egm_5fwrapper_2eproto.base);
  ::memset(&robot_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&external_) -
      reinterpret_cast<char*>(&robot_)) + sizeof(external_));
}

Output::~Output() {
  // @@protoc_insertion_point(destructor:abb.egm.wrapper.Output)
  SharedDtor();
}

void Output::SharedDtor() {
  if (this != internal_default_instance()) delete robot_;
  if (this != internal_default_instance()) delete external_;
}

void Output::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Output& Output::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Output_egm_5fwrapper_2eproto.base);
  return *internal_default_instance();
}


void Output::Clear() {
// @@protoc_insertion_point(message_clear_start:abb.egm.wrapper.Output)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(robot_ != NULL);
      robot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(external_ != NULL);
      external_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Output::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Output*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::Robot::_InternalParse;
        object = msg->mutable_robot();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::abb::egm::wrapper::External::_InternalParse;
        object = msg->mutable_external();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Output::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:abb.egm.wrapper.Output)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .abb.egm.wrapper.Robot robot = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_robot()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .abb.egm.wrapper.External external = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:abb.egm.wrapper.Output)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:abb.egm.wrapper.Output)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Output::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:abb.egm.wrapper.Output)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::robot(this), output);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::external(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:abb.egm.wrapper.Output)
}

::google::protobuf::uint8* Output::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:abb.egm.wrapper.Output)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .abb.egm.wrapper.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::robot(this), deterministic, target);
  }

  // optional .abb.egm.wrapper.External external = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::external(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:abb.egm.wrapper.Output)
  return target;
}

size_t Output::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:abb.egm.wrapper.Output)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .abb.egm.wrapper.Robot robot = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *robot_);
    }

    // optional .abb.egm.wrapper.External external = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *external_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Output::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:abb.egm.wrapper.Output)
  GOOGLE_DCHECK_NE(&from, this);
  const Output* source =
      ::google::protobuf::DynamicCastToGenerated<Output>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:abb.egm.wrapper.Output)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:abb.egm.wrapper.Output)
    MergeFrom(*source);
  }
}

void Output::MergeFrom(const Output& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:abb.egm.wrapper.Output)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_robot()->::abb::egm::wrapper::Robot::MergeFrom(from.robot());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_external()->::abb::egm::wrapper::External::MergeFrom(from.external());
    }
  }
}

void Output::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:abb.egm.wrapper.Output)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Output::CopyFrom(const Output& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:abb.egm.wrapper.Output)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Output::IsInitialized() const {
  return true;
}

void Output::Swap(Output* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Output::InternalSwap(Output* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(robot_, other->robot_);
  swap(external_, other->external_);
}

::google::protobuf::Metadata Output::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_egm_5fwrapper_2eproto);
  return ::file_level_metadata_egm_5fwrapper_2eproto[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace wrapper
}  // namespace egm
}  // namespace abb
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::Header* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Header >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Header >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::Status* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Status >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Status >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::Joints* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Joints >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Joints >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::JointSpace* Arena::CreateMaybeMessage< ::abb::egm::wrapper::JointSpace >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::JointSpace >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::Cartesian* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Cartesian >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Cartesian >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::Euler* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Euler >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Euler >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::Quaternion* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Quaternion >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Quaternion >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::CartesianPose* Arena::CreateMaybeMessage< ::abb::egm::wrapper::CartesianPose >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::CartesianPose >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::CartesianVelocity* Arena::CreateMaybeMessage< ::abb::egm::wrapper::CartesianVelocity >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::CartesianVelocity >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::CartesianSpace* Arena::CreateMaybeMessage< ::abb::egm::wrapper::CartesianSpace >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::CartesianSpace >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::Robot* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Robot >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Robot >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::External* Arena::CreateMaybeMessage< ::abb::egm::wrapper::External >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::External >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::Feedback* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Feedback >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Feedback >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::Planned* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Planned >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Planned >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::Input* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Input >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Input >(arena);
}
template<> PROTOBUF_NOINLINE ::abb::egm::wrapper::Output* Arena::CreateMaybeMessage< ::abb::egm::wrapper::Output >(Arena* arena) {
  return Arena::CreateInternal< ::abb::egm::wrapper::Output >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
